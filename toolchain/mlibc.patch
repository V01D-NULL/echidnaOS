diff --git a/mlibc-orig/meson.build b/mlibc/meson.build
index 3818563..7c788af 100644
--- a/mlibc-orig/meson.build
+++ b/mlibc/meson.build
@@ -8,7 +8,7 @@ rtdl_include_dirs = [
 ]
 libc_include_dirs = [
 	include_directories('options/internal/include'),
-	include_directories('options/internal/x86_64-include'),
+	include_directories('options/internal/' + host_machine.cpu_family() + '-include'),
 	include_directories('options/elf/include'),
 	include_directories('options/lsb/include'),
 	include_directories('options/glibc/include'),
@@ -89,6 +89,11 @@ elif host_machine.system() == 'qword'
 	rtdl_include_dirs += include_directories('sysdeps/qword/include')
 	libc_include_dirs += include_directories('sysdeps/qword/include')
 	subdir('sysdeps/qword')
+elif host_machine.system() == 'echidnaos'
+	disable_linux_option = true
+	rtdl_include_dirs += include_directories('sysdeps/echidnaos/include')
+	libc_include_dirs += include_directories('sysdeps/echidnaos/include')
+	subdir('sysdeps/echidnaos')
 elif host_machine.system() == 'sigma'
 	#disable_linux_option = true
 	rtdl_include_dirs += include_directories('sysdeps/sigma/include')
@@ -146,8 +151,8 @@ internal_sources = [
 	'options/internal/gcc/guard-abi.cpp',
 	'options/internal/gcc/initfini.cpp',
 	'options/internal/gcc-extra/cxxabi.cpp',
-	'options/internal/x86_64/setjmp.S',
-	'options/internal/x86_64/thread.cpp',
+	'options/internal' / host_machine.cpu_family() / 'setjmp.S',
+	'options/internal' / host_machine.cpu_family() / 'thread.cpp',
 ]
 
 if not static
@@ -186,11 +191,11 @@ rtdl_sources += [
 	'options/internal/generic/frigg.cpp',
 	'options/rtdl/generic/main.cpp',
 	'options/rtdl/generic/linker.cpp',
-	'options/rtdl/x86_64/runtime.S',
+	'options/rtdl' / host_machine.cpu_family() / 'runtime.S',
 ]
 
 if not static
-	rtdl_sources += 'options/rtdl/x86_64/entry.S'
+	rtdl_sources += 'options/rtdl' / host_machine.cpu_family() / 'entry.S'
 endif
 
 subdir('options/elf')
@@ -229,12 +234,6 @@ if not headers_only
 		shared_library('util', 'libutil/src/dummy.cpp', install: true)
 		shared_library('m', 'libm/src/dummy.cpp', install: true)
 	else
-		ldso_lib = static_library('ld', rtdl_sources,
-				name_prefix: '',
-				cpp_args: ['-fvisibility=hidden', '-DMLIBC_BUILDING_RTDL', '-DFRIGG_HAVE_LIBC'],
-				include_directories: rtdl_include_dirs,
-				dependencies: rtdl_deps,
-				install: false)
 		libc = static_library('c',
 				[
 					libc_sources,
@@ -242,17 +241,17 @@ if not headers_only
 					ansi_sources,
                                         lsb_sources,
 				],
+				pic: false,
 				cpp_args: ['-DFRIGG_HAVE_LIBC'],
 				include_directories: libc_include_dirs,
 				dependencies: libc_deps,
-				link_with: [ldso_lib],
-				link_whole: [libc_sublibs, ldso_lib],
+				link_whole: libc_sublibs,
 				install: true)
 
-		static_library('pthread', 'libpthread/src/dummy.cpp', install: true)
-		static_library('rt', 'librt/src/dummy.cpp', install: true)
-		static_library('util', 'libutil/src/dummy.cpp', install: true)
-		static_library('m', 'libm/src/dummy.cpp', install: true)
+		static_library('pthread', 'libpthread/src/dummy.cpp', pic: false, install: true)
+		static_library('rt', 'librt/src/dummy.cpp', pic: false, install: true)
+		static_library('util', 'libutil/src/dummy.cpp', pic: false, install: true)
+		static_library('m', 'libm/src/dummy.cpp', pic: false, install: true)
 	endif
 endif
 
diff --git a/mlibc-orig/options/ansi/generic/stdlib-stubs.cpp b/mlibc/options/ansi/generic/stdlib-stubs.cpp
index cde5af7..3c5063b 100644
--- a/mlibc-orig/options/ansi/generic/stdlib-stubs.cpp
+++ b/mlibc/options/ansi/generic/stdlib-stubs.cpp
@@ -99,7 +99,7 @@ long strtol(const char *__restrict string, char **__restrict end, int base) {
 	return negative ? -result : result;
 }
 long long strtoll(const char *__restrict string, char **__restrict end, int base) {
-	static_assert(sizeof(long long) == sizeof(long));
+	//static_assert(sizeof(long long) == sizeof(long));
 	return strtol(string, end, base);
 }
 // this function is copied from newlib and available under a BSD license
@@ -154,7 +154,7 @@ unsigned long strtoul(const char *__restrict nptr, char **__restrict endptr, int
 	return (acc);
 }
 unsigned long long strtoull(const char *__restrict string, char **__restrict end, int base) {
-	static_assert(sizeof(unsigned long long) == sizeof(unsigned long));
+	//static_assert(sizeof(unsigned long long) == sizeof(unsigned long));
 	return strtoul(string, end, base);
 }
 
diff --git a/mlibc-orig/options/elf/generic/startup.cpp b/mlibc/options/elf/generic/startup.cpp
index 73cc50e..97f2a99 100644
--- a/mlibc-orig/options/elf/generic/startup.cpp
+++ b/mlibc/options/elf/generic/startup.cpp
@@ -6,6 +6,7 @@
 #include <bits/ensure.h>
 #include <mlibc/elf/startup.h>
 #include <mlibc/environment.hpp>
+#include <mlibc/debug.hpp>
 
 extern "C" size_t __init_array_start[];
 extern "C" size_t __init_array_end[];
@@ -21,16 +22,17 @@ struct global_constructor_guard {
 static global_constructor_guard g;
 
 void __mlibc_run_constructors() {
-/*
     if (!constructors_ran_already) {
+        mlibc::infoLogger() << "mlibc: __init_array_start: "<<(void*)__init_array_start<< frg::endlog;
+        mlibc::infoLogger() << "mlibc: __init_array_end: "<<(void*)__init_array_end<< frg::endlog;
         size_t constructor_count = (size_t)__init_array_end - (size_t)__init_array_start;
         constructor_count /= sizeof(void*);
         for (size_t i = 0; i < constructor_count; i++) {
             void (*ptr)(void) = (void(*)(void))(__init_array_start[i]);
+            mlibc::infoLogger() << "mlibc: running constructor "<<(void*)ptr<< frg::endlog;
             ptr();
         }
     }
-*/
 }
 
 namespace mlibc {
diff --git a/mlibc-orig/options/internal/gcc-extra/mlibc_crtbegin.S b/mlibc/options/internal/gcc-extra/mlibc_crtbegin.S
index 77b143b..f3990b9 100644
--- a/mlibc-orig/options/internal/gcc-extra/mlibc_crtbegin.S
+++ b/mlibc/options/internal/gcc-extra/mlibc_crtbegin.S
@@ -3,7 +3,7 @@
 .hidden __dso_handle
 .global __dso_handle
 __dso_handle:
-	.quad __dso_handle
+	.long __dso_handle
 
 .section .init
 .hidden _init
diff --git a/mlibc/options/internal/x86/thread.cpp b/mlibc/options/internal/x86/thread.cpp
new file mode 100644
index 0000000..671e77e
--- /dev/null
+++ b/mlibc/options/internal/x86/thread.cpp
@@ -0,0 +1,13 @@
+#include <mlibc/thread.hpp>
+
+#include <stdint.h>
+
+namespace mlibc {
+
+Tcb *get_current_tcb() {
+	uintptr_t ptr;
+	asm ("movl %%gs:0, %0" : "=r"(ptr));
+	return reinterpret_cast<Tcb *>(ptr);
+}
+
+} // namespace mlibc
diff --git a/mlibc/options/internal/x86-include/mlibc/arch-defs.hpp b/mlibc/options/internal/x86-include/mlibc/arch-defs.hpp
new file mode 100644
index 0000000..0a4789f
--- /dev/null
+++ b/mlibc/options/internal/x86-include/mlibc/arch-defs.hpp
@@ -0,0 +1,12 @@
+#ifndef MLIBC_ARCH_DEFS_HPP
+#define MLIBC_ARCH_DEFS_HPP
+
+#include <stddef.h>
+
+namespace mlibc {
+
+inline constexpr size_t page_size = 0x1000;
+
+} // namespace mlibc
+
+#endif // MLIBC_ARCH_DEFS_HPP
diff --git a/mlibc-orig/options/rtdl/generic/main.cpp b/mlibc/options/rtdl/generic/main.cpp
index c18beeb..bd3fe2c 100644
--- a/mlibc-orig/options/rtdl/generic/main.cpp
+++ b/mlibc/options/rtdl/generic/main.cpp
@@ -267,7 +267,7 @@ struct __abi_tls_entry {
 	uint64_t offset;
 };
 
-static_assert(sizeof(__abi_tls_entry) == 16, "Bad __abi_tls_entry size");
+//static_assert(sizeof(__abi_tls_entry) == 16, "Bad __abi_tls_entry size");
 
 const char *lastError;
 
diff --git a/mlibc/options/rtdl/x86/entry.S b/mlibc/options/rtdl/x86/entry.S
new file mode 100644
index 0000000..c4e3392
--- /dev/null
+++ b/mlibc/options/rtdl/x86/entry.S
@@ -0,0 +1,10 @@
+
+.global _start
+_start:
+	call relocateSelf
+
+	mov %esp, %eax
+    push %eax
+	call interpreterMain
+
+	jmp *%rax
diff --git a/mlibc/options/rtdl/x86/runtime.S b/mlibc/options/rtdl/x86/runtime.S
new file mode 100644
index 0000000..c233646
--- /dev/null
+++ b/mlibc/options/rtdl/x86/runtime.S
@@ -0,0 +1,4 @@
+
+.global pltRelocateStub
+pltRelocateStub:
+	# TODO: implement this lol
diff --git a/mlibc/subprojects/cxxshim/.git/HEAD b/mlibc/subprojects/cxxshim/.git/HEAD
new file mode 100644
index 0000000..cb089cd
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/HEAD
@@ -0,0 +1 @@
+ref: refs/heads/master
diff --git a/mlibc/subprojects/cxxshim/.git/config b/mlibc/subprojects/cxxshim/.git/config
new file mode 100644
index 0000000..3583c23
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/config
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/managarm/cxxshim.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff --git a/mlibc/subprojects/cxxshim/.git/description b/mlibc/subprojects/cxxshim/.git/description
new file mode 100644
index 0000000..498b267
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/description
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff --git a/mlibc/subprojects/cxxshim/.git/hooks/applypatch-msg.sample b/mlibc/subprojects/cxxshim/.git/hooks/applypatch-msg.sample
new file mode 100755
index 0000000..a5d7b84
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/hooks/applypatch-msg.sample
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
+:
diff --git a/mlibc/subprojects/cxxshim/.git/hooks/commit-msg.sample b/mlibc/subprojects/cxxshim/.git/hooks/commit-msg.sample
new file mode 100755
index 0000000..b58d118
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/hooks/commit-msg.sample
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff --git a/mlibc/subprojects/cxxshim/.git/hooks/fsmonitor-watchman.sample b/mlibc/subprojects/cxxshim/.git/hooks/fsmonitor-watchman.sample
new file mode 100755
index 0000000..14ed0aa
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/hooks/fsmonitor-watchman.sample
@@ -0,0 +1,173 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use IPC::Open2;
+
+# An example hook script to integrate Watchman
+# (https://facebook.github.io/watchman/) with git to speed up detecting
+# new and modified files.
+#
+# The hook is passed a version (currently 2) and last update token
+# formatted as a string and outputs to stdout a new update token and
+# all files that have been modified since the update token. Paths must
+# be relative to the root of the working tree and separated by a single NUL.
+#
+# To enable this hook, rename this file to "query-watchman" and set
+# 'git config core.fsmonitor .git/hooks/query-watchman'
+#
+my ($version, $last_update_token) = @ARGV;
+
+# Uncomment for debugging
+# print STDERR "$0 $version $last_update_token\n";
+
+# Check the hook interface version
+if ($version ne 2) {
+	die "Unsupported query-fsmonitor hook version '$version'.\n" .
+	    "Falling back to scanning...\n";
+}
+
+my $git_work_tree = get_working_dir();
+
+my $retry = 1;
+
+my $json_pkg;
+eval {
+	require JSON::XS;
+	$json_pkg = "JSON::XS";
+	1;
+} or do {
+	require JSON::PP;
+	$json_pkg = "JSON::PP";
+};
+
+launch_watchman();
+
+sub launch_watchman {
+	my $o = watchman_query();
+	if (is_work_tree_watched($o)) {
+		output_result($o->{clock}, @{$o->{files}});
+	}
+}
+
+sub output_result {
+	my ($clockid, @files) = @_;
+
+	# Uncomment for debugging watchman output
+	# open (my $fh, ">", ".git/watchman-output.out");
+	# binmode $fh, ":utf8";
+	# print $fh "$clockid\n@files\n";
+	# close $fh;
+
+	binmode STDOUT, ":utf8";
+	print $clockid;
+	print "\0";
+	local $, = "\0";
+	print @files;
+}
+
+sub watchman_clock {
+	my $response = qx/watchman clock "$git_work_tree"/;
+	die "Failed to get clock id on '$git_work_tree'.\n" .
+		"Falling back to scanning...\n" if $? != 0;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub watchman_query {
+	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
+	or die "open2() failed: $!\n" .
+	"Falling back to scanning...\n";
+
+	# In the query expression below we're asking for names of files that
+	# changed since $last_update_token but not from the .git folder.
+	#
+	# To accomplish this, we're using the "since" generator to use the
+	# recency index to select candidate nodes and "fields" to limit the
+	# output to file names only. Then we're using the "expression" term to
+	# further constrain the results.
+	if (substr($last_update_token, 0, 1) eq "c") {
+		$last_update_token = "\"$last_update_token\"";
+	}
+	my $query = <<"	END";
+		["query", "$git_work_tree", {
+			"since": $last_update_token,
+			"fields": ["name"],
+			"expression": ["not", ["dirname", ".git"]]
+		}]
+	END
+
+	# Uncomment for debugging the watchman query
+	# open (my $fh, ">", ".git/watchman-query.json");
+	# print $fh $query;
+	# close $fh;
+
+	print CHLD_IN $query;
+	close CHLD_IN;
+	my $response = do {local $/; <CHLD_OUT>};
+
+	# Uncomment for debugging the watch response
+	# open ($fh, ">", ".git/watchman-response.json");
+	# print $fh $response;
+	# close $fh;
+
+	die "Watchman: command returned no output.\n" .
+	"Falling back to scanning...\n" if $response eq "";
+	die "Watchman: command returned invalid output: $response\n" .
+	"Falling back to scanning...\n" unless $response =~ /^\{/;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub is_work_tree_watched {
+	my ($output) = @_;
+	my $error = $output->{error};
+	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
+		$retry--;
+		my $response = qx/watchman watch "$git_work_tree"/;
+		die "Failed to make watchman watch '$git_work_tree'.\n" .
+		    "Falling back to scanning...\n" if $? != 0;
+		$output = $json_pkg->new->utf8->decode($response);
+		$error = $output->{error};
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		# Uncomment for debugging watchman output
+		# open (my $fh, ">", ".git/watchman-output.out");
+		# close $fh;
+
+		# Watchman will always return all files on the first query so
+		# return the fast "everything is dirty" flag to git and do the
+		# Watchman query just to get it over with now so we won't pay
+		# the cost in git to look up each individual file.
+		my $o = watchman_clock();
+		$error = $output->{error};
+
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		output_result($o->{clock}, ("/"));
+		$last_update_token = $o->{clock};
+
+		eval { launch_watchman() };
+		return 0;
+	}
+
+	die "Watchman: $error.\n" .
+	"Falling back to scanning...\n" if $error;
+
+	return 1;
+}
+
+sub get_working_dir {
+	my $working_dir;
+	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+		$working_dir = Win32::GetCwd();
+		$working_dir =~ tr/\\/\//;
+	} else {
+		require Cwd;
+		$working_dir = Cwd::cwd();
+	}
+
+	return $working_dir;
+}
diff --git a/mlibc/subprojects/cxxshim/.git/hooks/post-update.sample b/mlibc/subprojects/cxxshim/.git/hooks/post-update.sample
new file mode 100755
index 0000000..ec17ec1
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/hooks/post-update.sample
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff --git a/mlibc/subprojects/cxxshim/.git/hooks/pre-applypatch.sample b/mlibc/subprojects/cxxshim/.git/hooks/pre-applypatch.sample
new file mode 100755
index 0000000..4142082
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/hooks/pre-applypatch.sample
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+precommit="$(git rev-parse --git-path hooks/pre-commit)"
+test -x "$precommit" && exec "$precommit" ${1+"$@"}
+:
diff --git a/mlibc/subprojects/cxxshim/.git/hooks/pre-commit.sample b/mlibc/subprojects/cxxshim/.git/hooks/pre-commit.sample
new file mode 100755
index 0000000..e144712
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/hooks/pre-commit.sample
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=$(git hash-object -t tree /dev/null)
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --type=bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff --git a/mlibc/subprojects/cxxshim/.git/hooks/pre-merge-commit.sample b/mlibc/subprojects/cxxshim/.git/hooks/pre-merge-commit.sample
new file mode 100755
index 0000000..399eab1
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/hooks/pre-merge-commit.sample
@@ -0,0 +1,13 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git merge" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message to
+# stderr if it wants to stop the merge commit.
+#
+# To enable this hook, rename this file to "pre-merge-commit".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+        exec "$GIT_DIR/hooks/pre-commit"
+:
diff --git a/mlibc/subprojects/cxxshim/.git/hooks/pre-push.sample b/mlibc/subprojects/cxxshim/.git/hooks/pre-push.sample
new file mode 100755
index 0000000..6187dbf
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/hooks/pre-push.sample
@@ -0,0 +1,53 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo >&2 "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff --git a/mlibc/subprojects/cxxshim/.git/hooks/pre-rebase.sample b/mlibc/subprojects/cxxshim/.git/hooks/pre-rebase.sample
new file mode 100755
index 0000000..6cbef5c
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/hooks/pre-rebase.sample
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up to date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+<<\DOC_END
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
+
+DOC_END
diff --git a/mlibc/subprojects/cxxshim/.git/hooks/pre-receive.sample b/mlibc/subprojects/cxxshim/.git/hooks/pre-receive.sample
new file mode 100755
index 0000000..a1fd29e
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/hooks/pre-receive.sample
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to make use of push options.
+# The example simply echoes all push options that start with 'echoback='
+# and rejects all pushes when the "reject" push option is used.
+#
+# To enable this hook, rename this file to "pre-receive".
+
+if test -n "$GIT_PUSH_OPTION_COUNT"
+then
+	i=0
+	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
+	do
+		eval "value=\$GIT_PUSH_OPTION_$i"
+		case "$value" in
+		echoback=*)
+			echo "echo from the pre-receive-hook: ${value#*=}" >&2
+			;;
+		reject)
+			exit 1
+		esac
+		i=$((i + 1))
+	done
+fi
diff --git a/mlibc/subprojects/cxxshim/.git/hooks/prepare-commit-msg.sample b/mlibc/subprojects/cxxshim/.git/hooks/prepare-commit-msg.sample
new file mode 100755
index 0000000..10fa14c
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/hooks/prepare-commit-msg.sample
@@ -0,0 +1,42 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples. The first one removes the
+# "# Please enter the commit message..." help message.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+COMMIT_MSG_FILE=$1
+COMMIT_SOURCE=$2
+SHA1=$3
+
+/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
+
+# case "$COMMIT_SOURCE,$SHA1" in
+#  ,|template,)
+#    /usr/bin/perl -i.bak -pe '
+#       print "\n" . `git diff --cached --name-status -r`
+# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
+#  *) ;;
+# esac
+
+# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
+# if test -z "$COMMIT_SOURCE"
+# then
+#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
+# fi
diff --git a/mlibc/subprojects/cxxshim/.git/hooks/update.sample b/mlibc/subprojects/cxxshim/.git/hooks/update.sample
new file mode 100755
index 0000000..5014c4b
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/hooks/update.sample
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to block unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --type=bool hooks.allowunannotated)
+allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
+allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
+allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
diff --git a/mlibc/subprojects/cxxshim/.git/index b/mlibc/subprojects/cxxshim/.git/index
new file mode 100644
index 0000000..918a690
Binary files /dev/null and b/mlibc/subprojects/cxxshim/.git/index differ
diff --git a/mlibc/subprojects/cxxshim/.git/info/exclude b/mlibc/subprojects/cxxshim/.git/info/exclude
new file mode 100644
index 0000000..a5196d1
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/info/exclude
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff --git a/mlibc/subprojects/cxxshim/.git/logs/HEAD b/mlibc/subprojects/cxxshim/.git/logs/HEAD
new file mode 100644
index 0000000..6286b2b
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/logs/HEAD
@@ -0,0 +1,2 @@
+0000000000000000000000000000000000000000 43c84fa155156bdb8db1208a3fc789fda22df29c mintsuki <mintsuki@protonmail.com> 1602036085 +0200	clone: from https://github.com/managarm/cxxshim.git
+43c84fa155156bdb8db1208a3fc789fda22df29c 43c84fa155156bdb8db1208a3fc789fda22df29c mintsuki <mintsuki@protonmail.com> 1602036085 +0200	checkout: moving from master to master
diff --git a/mlibc/subprojects/cxxshim/.git/logs/refs/heads/master b/mlibc/subprojects/cxxshim/.git/logs/refs/heads/master
new file mode 100644
index 0000000..ada4327
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/logs/refs/heads/master
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 43c84fa155156bdb8db1208a3fc789fda22df29c mintsuki <mintsuki@protonmail.com> 1602036085 +0200	clone: from https://github.com/managarm/cxxshim.git
diff --git a/mlibc/subprojects/cxxshim/.git/logs/refs/remotes/origin/HEAD b/mlibc/subprojects/cxxshim/.git/logs/refs/remotes/origin/HEAD
new file mode 100644
index 0000000..ada4327
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/logs/refs/remotes/origin/HEAD
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 43c84fa155156bdb8db1208a3fc789fda22df29c mintsuki <mintsuki@protonmail.com> 1602036085 +0200	clone: from https://github.com/managarm/cxxshim.git
diff --git a/mlibc/subprojects/cxxshim/.git/objects/pack/pack-7ed93274bd26ade7939fb2402c626904d315698b.idx b/mlibc/subprojects/cxxshim/.git/objects/pack/pack-7ed93274bd26ade7939fb2402c626904d315698b.idx
new file mode 100644
index 0000000..ca7834d
Binary files /dev/null and b/mlibc/subprojects/cxxshim/.git/objects/pack/pack-7ed93274bd26ade7939fb2402c626904d315698b.idx differ
diff --git a/mlibc/subprojects/cxxshim/.git/objects/pack/pack-7ed93274bd26ade7939fb2402c626904d315698b.pack b/mlibc/subprojects/cxxshim/.git/objects/pack/pack-7ed93274bd26ade7939fb2402c626904d315698b.pack
new file mode 100644
index 0000000..535f1a5
Binary files /dev/null and b/mlibc/subprojects/cxxshim/.git/objects/pack/pack-7ed93274bd26ade7939fb2402c626904d315698b.pack differ
diff --git a/mlibc/subprojects/cxxshim/.git/packed-refs b/mlibc/subprojects/cxxshim/.git/packed-refs
new file mode 100644
index 0000000..bfe9dc5
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/packed-refs
@@ -0,0 +1,2 @@
+# pack-refs with: peeled fully-peeled sorted 
+43c84fa155156bdb8db1208a3fc789fda22df29c refs/remotes/origin/master
diff --git a/mlibc/subprojects/cxxshim/.git/refs/heads/master b/mlibc/subprojects/cxxshim/.git/refs/heads/master
new file mode 100644
index 0000000..3eb6bd3
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/refs/heads/master
@@ -0,0 +1 @@
+43c84fa155156bdb8db1208a3fc789fda22df29c
diff --git a/mlibc/subprojects/cxxshim/.git/refs/remotes/origin/HEAD b/mlibc/subprojects/cxxshim/.git/refs/remotes/origin/HEAD
new file mode 100644
index 0000000..6efe28f
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/.git/refs/remotes/origin/HEAD
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff --git a/mlibc/subprojects/cxxshim/LICENSE b/mlibc/subprojects/cxxshim/LICENSE
new file mode 100644
index 0000000..bbd1c21
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/LICENSE
@@ -0,0 +1,7 @@
+Copyright 2017-2020 cxxshim Contributors
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/mlibc/subprojects/cxxshim/clang-coroutine/include/experimental/coroutine b/mlibc/subprojects/cxxshim/clang-coroutine/include/experimental/coroutine
new file mode 100644
index 0000000..a7fd8e0
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/clang-coroutine/include/experimental/coroutine
@@ -0,0 +1,91 @@
+#ifndef _CXXSHIM_EXPERIMENTAL_COROUTINE
+#define _CXXSHIM_EXPERIMENTAL_COROUTINE
+
+namespace std {
+namespace experimental {
+
+template<typename ReturnType, typename... Args>
+struct coroutine_traits {
+    using promise_type = typename ReturnType::promise_type;
+};
+
+template<typename Promise = void>
+struct coroutine_handle;
+
+template<>
+struct coroutine_handle<void> {
+    template<typename Promise>
+    friend struct coroutine_handle;
+
+    static coroutine_handle<> from_address(void *frame) {
+        return coroutine_handle<>{frame};
+    }
+
+	coroutine_handle()
+	: _frame{nullptr} { }
+
+	explicit operator bool () {
+		return _frame;
+	}
+
+    void *address() {
+        return _frame;
+    }
+
+    bool done() {
+        return __builtin_coro_done(_frame);
+    }
+
+    void resume() {
+        __builtin_coro_resume(_frame);
+    }
+
+    void destroy() {
+        __builtin_coro_destroy(_frame);
+    }
+
+    void operator() () {
+        resume();
+    }
+
+private:
+    explicit coroutine_handle(void *frame)
+    : _frame{frame} { }
+
+    void *_frame;
+};
+
+template<typename Promise>
+struct coroutine_handle : coroutine_handle<> {
+	coroutine_handle() = default;
+
+    static coroutine_handle<Promise> from_promise(Promise &p) {
+        auto frame = __builtin_coro_promise(&p, alignof(Promise), true);
+        return coroutine_handle{frame};
+    }
+
+    Promise &promise() {
+        auto p_ptr = __builtin_coro_promise(_frame, alignof(Promise), false);
+        return *static_cast<Promise *>(p_ptr);
+    }
+
+private:
+    explicit coroutine_handle(void *frame)
+    : coroutine_handle<>{frame} { }
+};
+
+struct suspend_never {
+    bool await_ready() const { return true; }
+    void await_suspend(coroutine_handle<>) const {}
+    void await_resume() const {}
+};
+
+struct suspend_always {
+    bool await_ready() const { return false; }
+    void await_suspend(coroutine_handle<>) const {}
+    void await_resume() const {}
+};
+
+} } // namespace std::experimental
+
+#endif // _CXXSHIM_EXPERIMENTAL_COROUTINE
diff --git a/mlibc/subprojects/cxxshim/meson.build b/mlibc/subprojects/cxxshim/meson.build
new file mode 100644
index 0000000..f112416
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/meson.build
@@ -0,0 +1,16 @@
+project('cxxshim', 'cpp')
+
+incl = include_directories('stage2/include')
+
+# TODO: install_headers
+
+cxxshim_dep = declare_dependency(include_directories: incl)
+
+clang_coroutine_dep = declare_dependency(
+	include_directories: include_directories('clang-coroutine/include')
+)
+
+std_coroutine_dep = declare_dependency(
+	include_directories: include_directories('std-coroutine/include')
+)
+
diff --git a/mlibc/subprojects/cxxshim/stage2/include/algorithm b/mlibc/subprojects/cxxshim/stage2/include/algorithm
new file mode 100644
index 0000000..4f32ef8
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/stage2/include/algorithm
@@ -0,0 +1,69 @@
+#ifndef _CXXSHIM_ALGORITHM
+#define _CXXSHIM_ALGORITHM
+
+#include <initializer_list>
+
+namespace std {
+
+template<typename T>
+const T &min(const T &a, const T &b) {
+	return (b < a) ? b : a;
+}
+
+template<typename T>
+const T &max(const T &a, const T &b) {
+	return (a < b) ? b : a;
+}
+
+template <typename T>
+constexpr T min(std::initializer_list<T> list) {
+	auto it = list.begin();
+	T x = *it;
+	++it;
+	while(it != list.end()) {
+		if (*it < x)
+			x = *it;
+		++it;
+	}
+	return x;
+}
+
+template <typename T>
+constexpr T max(std::initializer_list<T> list) {
+	auto it = list.begin();
+	T x = *it;
+	++it;
+	while(it != list.end()) {
+		if (*it > x)
+			x = *it;
+		++it;
+	}
+	return x;
+}
+
+template<typename It, typename T>
+It find(It begin, It end, const T &value) {
+	for(auto it = begin; it != end; ++it)
+		if(*it == value)
+			return it;
+	return end;
+}
+
+template<typename It, typename Pred>
+It find_if(It begin, It end, Pred p) {
+	for(auto it = begin; it != end; ++it)
+		if(p(*it))
+			return it;
+	return end;
+}
+
+template<typename InIt, typename OutIt>
+OutIt copy(InIt begin, InIt end, OutIt d_first) {
+	while (begin != end)
+		*d_first++ = *begin++;
+	return d_first;
+}
+
+} // namespace std
+
+#endif // _CXXSHIM_ALGORITHM
diff --git a/mlibc/subprojects/cxxshim/stage2/include/initializer_list b/mlibc/subprojects/cxxshim/stage2/include/initializer_list
new file mode 100644
index 0000000..4eeda90
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/stage2/include/initializer_list
@@ -0,0 +1,40 @@
+#ifndef _CXXSHIM_INITIALIZER_LIST
+#define _CXXSHIM_INITIALIZER_LIST
+
+#include <stddef.h>
+
+namespace std {
+
+template<typename T>
+class initializer_list {
+public:
+	using value_type = T;
+	using iterator = const T*;
+	using const_iterator = const T*;
+	using size_type = size_t;
+
+	constexpr initializer_list() noexcept
+	: _array(0), _len(0) { }
+
+	constexpr size_type size() const noexcept {
+		return _len;
+	}
+
+	constexpr const_iterator begin() const noexcept {
+		return _array;
+	}
+
+	constexpr const_iterator end() const noexcept {
+		return _array + _len;
+	}
+private:
+	iterator _array;
+	size_type _len;
+
+	constexpr initializer_list(const_iterator array, size_type len)
+	: _array(array), _len(len) { }
+};
+
+} // namespace std
+
+#endif // _CXXSHIM_INITIALIZER_LIST
diff --git a/mlibc/subprojects/cxxshim/stage2/include/iterator b/mlibc/subprojects/cxxshim/stage2/include/iterator
new file mode 100644
index 0000000..712d9a4
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/stage2/include/iterator
@@ -0,0 +1,42 @@
+#ifndef _CXXSHIM_ITERATOR
+#define _CXXSHIM_ITERATOR
+
+namespace std {
+
+template<class Container>
+class back_insert_iterator {
+public:
+	explicit back_insert_iterator(Container &c) : _c(&c) { }
+
+	back_insert_iterator operator*() {
+		// no-op
+		return *this;
+	}
+
+	back_insert_iterator operator++() {
+		// no-op
+		return *this;
+	}
+	back_insert_iterator operator++(int val) {
+		// no-op
+		(void) val;
+		return *this;
+	}
+
+	back_insert_iterator &operator=(const typename Container::value_type
+	    &value) {
+		_c->push_back(value);
+		return *this;
+	}
+protected:
+	Container *_c;
+};
+
+template<class Container>
+back_insert_iterator<Container> back_inserter(Container &c) {
+	return back_insert_iterator<Container>(c);
+}
+
+} // namespace std
+
+#endif // _CXXSHIM_ITERATOR
diff --git a/mlibc/subprojects/cxxshim/stage2/include/new b/mlibc/subprojects/cxxshim/stage2/include/new
new file mode 100644
index 0000000..4e05a10
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/stage2/include/new
@@ -0,0 +1,27 @@
+#ifndef _CXXSHIM_NEW
+#define _CXXSHIM_NEW
+
+#include <stddef.h>
+
+#ifdef CXXSHIM_INTEGRATE_GCC
+
+#include_next <new>
+
+#else // CXXSHIM_INTEGRATE_GCC
+
+inline void *operator new (size_t size, void *p) {
+	return p;
+}
+
+namespace std {
+
+template<typename T>
+[[nodiscard]] constexpr T *launder(T *p) noexcept {
+	return __builtin_launder(p);
+}
+
+} // namespace std
+
+#endif // !(CXXSHIM_INTEGRATE_GCC)
+
+#endif // _CXXSHIM_NEW
diff --git a/mlibc/subprojects/cxxshim/stage2/include/tuple b/mlibc/subprojects/cxxshim/stage2/include/tuple
new file mode 100644
index 0000000..ac48dd5
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/stage2/include/tuple
@@ -0,0 +1,20 @@
+#ifndef _CXXSHIM_TUPLE
+#define _CXXSHIM_TUPLE
+
+namespace std {
+
+template<typename T>
+struct tuple_size;
+
+template<size_t I, typename T>
+struct tuple_element;
+
+template<typename T>
+inline constexpr size_t tuple_size_v = tuple_size<T>::value;
+
+template<size_t I, typename T>
+using tuple_element_t = typename tuple_element<I, T>::type;
+
+} // namespace std
+
+#endif // _CXXSHIM_TUPLE
diff --git a/mlibc/subprojects/cxxshim/stage2/include/type_traits b/mlibc/subprojects/cxxshim/stage2/include/type_traits
new file mode 100644
index 0000000..3ae1bf1
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/stage2/include/type_traits
@@ -0,0 +1,309 @@
+#ifndef _CXXSHIM_TYPE_TRAITS
+#define _CXXSHIM_TYPE_TRAITS
+
+#ifdef CXXSHIM_INTEGRATE_GCC
+
+#include_next <type_traits>
+
+#else // CXXSHIM_INTEGRATE_GCC
+
+namespace std {
+
+template<class T, T v>
+struct integral_constant {
+	static constexpr T value = v;
+	using value_type = T;
+	using type = integral_constant;
+
+	constexpr operator value_type() const noexcept {
+		return value;
+	}
+
+	constexpr value_type operator()() const noexcept {
+		return value;
+	}
+};
+
+typedef integral_constant<bool, true> true_type;
+typedef integral_constant<bool, false> false_type;
+
+#define _DEFINE_SPEC0(_Name, _Type, _Value) \
+	template<> \
+	struct _Name<_Type> \
+	: public integral_constant<bool, _Value> { }
+
+// TODO: add remove_cv support to this
+template<typename T>
+struct is_integral : public false_type { };
+
+_DEFINE_SPEC0(is_integral, bool, true);
+_DEFINE_SPEC0(is_integral, char, true);
+_DEFINE_SPEC0(is_integral, signed char, true);
+_DEFINE_SPEC0(is_integral, unsigned char, true);
+_DEFINE_SPEC0(is_integral, short, true);
+_DEFINE_SPEC0(is_integral, unsigned short, true);
+_DEFINE_SPEC0(is_integral, int, true);
+_DEFINE_SPEC0(is_integral, unsigned int, true);
+_DEFINE_SPEC0(is_integral, long, true);
+_DEFINE_SPEC0(is_integral, unsigned long, true);
+_DEFINE_SPEC0(is_integral, long long, true);
+_DEFINE_SPEC0(is_integral, unsigned long long, true);
+
+template<typename T>
+struct is_floating_point : public false_type { };
+
+_DEFINE_SPEC0(is_floating_point, float, true);
+_DEFINE_SPEC0(is_floating_point, double, true);
+_DEFINE_SPEC0(is_floating_point, long double, true);
+
+#undef _DEFINE_SPEC0
+
+template<typename T>
+struct is_arithmetic : public integral_constant<bool, is_integral<T>::value ||
+				is_floating_point<T>::value> { };
+
+namespace detail {
+
+template<typename T, bool = is_arithmetic<T>::value>
+struct is_unsigned : public integral_constant<bool, T(0) < T(-1)> { };
+
+template<typename T>
+struct is_unsigned<T, false> : public false_type { };
+
+template<typename T, bool = is_arithmetic<T>::value>
+struct is_signed : public integral_constant<bool, T(-1) < T(0)> { };
+
+template<typename T>
+struct is_signed<T, false> : public false_type { };
+
+template<typename T>
+struct type_identity { using type = T; };
+
+template<typename T>
+auto try_add_lvalue_reference(int) -> type_identity<T&>;
+template<typename T>
+auto try_add_lvalue_reference(...) -> type_identity<T>;
+
+template<typename T>
+auto try_add_rvalue_reference(int) -> type_identity<T&&>;
+template<typename T>
+auto try_add_rvalue_reference(...) -> type_identity<T>;
+
+} // namespace detail
+
+template<typename T>
+struct add_lvalue_reference : decltype(detail::try_add_lvalue_reference<T>(0)) {};
+template<typename T>
+using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;
+
+template<typename T>
+struct add_rvalue_reference : decltype(detail::try_add_rvalue_reference<T>(0)) {};
+template<typename T>
+using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;
+
+template<typename T>
+struct add_const
+{ using type = const T; };
+
+template<typename T>
+struct is_unsigned : public detail::is_unsigned<T>::type { };
+
+template<typename T>
+struct is_signed : public detail::is_signed<T>::type { };
+
+template<class T, class U>
+struct is_same : false_type {};
+
+template<class T>
+struct is_same<T, T> : true_type {};
+
+template<class T>
+struct is_void : is_same<T, void> {};
+
+template<typename T>
+add_rvalue_reference_t<T> declval();
+
+template<typename T>
+struct remove_reference {
+	typedef T type;
+};
+
+template<typename T>
+struct remove_reference<T &> {
+	typedef T type;
+};
+
+template<typename T>
+struct remove_reference<T &&> {
+	typedef T type;
+};
+
+template<typename T>
+using remove_reference_t = typename remove_reference<T>::type;
+
+namespace _void_impl {
+	template<typename... T>
+	struct helper {
+		using type = void;
+	};
+};
+
+template<typename... T>
+using void_t = typename _void_impl::helper<T...>::type;
+
+template<typename T>
+struct add_pointer {
+	using type = T *;
+};
+
+template<typename T>
+using add_pointer_t = typename add_pointer<T>::type;
+
+namespace _result_of_impl {
+	template<typename S, typename = void>
+	struct helper { };
+
+	template<typename F, typename... Args>
+	struct helper<F(Args...), void_t<decltype(declval<F>() (declval<Args>()...))>> {
+		using type = decltype(declval<F>() (declval<Args>()...));
+	};
+};
+
+template<typename T>
+using result_of_t = typename _result_of_impl::helper<T>::type;
+
+template<class F, class... ArgTypes>
+struct invoke_result {
+	using type = typename _result_of_impl::helper<F, ArgTypes...>::type;
+};
+
+template<class F, class... ArgTypes>
+using invoke_result_t = typename invoke_result<F, ArgTypes...>::type;
+
+template<bool B, class T = void>
+struct enable_if {};
+
+template<class T>
+struct enable_if<true, T> { typedef T type; };
+
+template<bool B, class T = void>
+using enable_if_t = typename enable_if<B, T>::type;
+
+template<class T, class... Args>
+struct is_constructible
+{ static constexpr bool value =  __is_constructible(T, Args...); };
+
+template<class T, class... Args>
+struct is_trivially_constructible
+{ static constexpr bool value = __is_trivially_constructible(T, Args...); };
+
+namespace _is_destructible_impl {
+	struct do_is_destructible_impl {
+		template<typename T, typename = decltype(declval<T&>().~_T())>
+		static true_type __test(int);
+
+		template<typename>
+		static false_type __test(...);
+	};
+
+	template<class T>
+	struct is_destructible_impl : do_is_destructible_impl {
+		using type = decltype(__test<T>(0));
+	};
+} // namespace _is_destructible_impl
+
+template<class T>
+struct is_destructible : _is_destructible_impl::is_destructible_impl<T>::type {};
+
+template<class T>
+struct is_trivially_destructible
+{ static constexpr bool value = __has_trivial_destructor(T); };
+
+template<class T, class... Args>
+inline constexpr bool is_constructible_v = is_constructible<T, Args...>::value;
+
+template<class T, class... Args>
+inline constexpr bool is_trivially_constructible_v = is_trivially_constructible<T, Args...>::value;
+
+template<class T>
+inline constexpr bool is_destructible_v = is_destructible<T>::value;
+
+template<class T>
+inline constexpr bool is_trivially_destructible_v = is_trivially_destructible<T>::value;
+
+template<class T>
+struct is_trivially_copy_constructible :
+	is_trivially_constructible<T, typename add_lvalue_reference<
+	typename add_const<T>::type>::type> {};
+
+template<class T>
+inline constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<T>::value;
+
+template<class T>
+struct is_trivially_move_constructible :
+	is_trivially_constructible<T, typename add_rvalue_reference<T>::type> {};
+
+template<class T>
+inline constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<T>::value;
+
+template<class T>
+struct is_default_constructible : is_constructible<T> {};
+
+template<class T>
+inline constexpr bool is_default_constructible_v = is_default_constructible<T>::value;
+
+template<class T, class U>
+struct is_trivially_assignable
+{ static constexpr bool value = __is_trivially_assignable(T, U); };
+
+template<class T>
+struct is_trivially_move_assignable : is_trivially_assignable<
+	typename add_lvalue_reference<T>::type,
+	typename add_rvalue_reference<T>::type> {};
+
+template<class T>
+struct is_trivially_copy_assignable : is_trivially_assignable<
+	typename add_lvalue_reference<T>::type,
+	typename add_lvalue_reference<const T>::type> {};
+
+template<class T, class U>
+inline constexpr bool is_trivially_assignable_v = is_trivially_assignable<T, U>::value;
+
+template <class T>
+inline constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<T>::value;
+
+template <class T>
+inline constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<T>::value;
+
+namespace detail {
+
+	template<class>
+	using true_type_for = true_type;
+
+	template<class T>
+	auto test_returnable(int) -> true_type_for<T()>;
+	template<class T>
+	auto test_returnable(...) -> false_type;
+
+	template<class From, class To>
+	auto test_nonvoid_convertible(int) -> true_type_for<
+		decltype(declval<void(&)(To)>()(declval<From>()))>;
+
+	template<class From, class To>
+	auto test_nonvoid_convertible(...) -> false_type;
+} // namespace detail
+
+template<class From, class To>
+struct is_convertible : integral_constant<bool,
+	(decltype(detail::test_returnable<To>(0))::value &&
+	decltype(detail::test_nonvoid_convertible<From, To>(0))::value) ||
+	(is_void<From>::value && is_void<To>::value)> {};
+
+template<class From, class To>
+inline constexpr bool is_convertible_v = is_convertible<From, To>::value;
+
+} // namespace std
+
+#endif // !defined(CXXSHIM_INTEGRATE_GCC)
+
+#endif // _CXXSHIM_TYPE_TRAITS
diff --git a/mlibc/subprojects/cxxshim/stage2/include/utility b/mlibc/subprojects/cxxshim/stage2/include/utility
new file mode 100644
index 0000000..545a8ac
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/stage2/include/utility
@@ -0,0 +1,68 @@
+#ifndef _CXXSHIM_UTILITY
+#define _CXXSHIM_UTILITY
+
+#include <stddef.h>
+#include <type_traits>
+
+#ifdef CXXSHIM_INTEGRATE_GCC
+#include <bits/move.h>
+#endif
+
+namespace std {
+
+#ifndef CXXSHIM_INTEGRATE_GCC
+template<typename T>
+constexpr remove_reference_t<T> move(T &&x) noexcept {
+	return static_cast<remove_reference_t<T> &&>(x);
+}
+
+template<typename T>
+constexpr T &&forward(remove_reference_t<T> &x) noexcept {
+	return static_cast<T &&>(x);
+}
+
+template<typename T>
+void swap(T &x, T &y) {
+	T temp{move(x)};
+	x = move(y);
+	y = move(temp);
+}
+#endif // !defined(CXXSHIM_INTEGRATE_GCC)
+
+template<class T, class U = T>
+T exchange(T &ref, U &&v) {
+	T temp = std::move(ref);
+	ref = std::forward<U>(v);
+	return temp;
+}
+
+template<typename I, I... Seq>
+class integer_sequence { };
+
+template<size_t... Seq>
+using index_sequence = integer_sequence<size_t, Seq...>;
+
+namespace _make_seq {
+	template<typename I, I X, I N, I... Seq>
+	struct helper {
+		using type = typename helper<I, X + 1, N, Seq..., X>::type;
+	};
+
+	template<typename I, I N, I... Seq>
+	struct helper<I, N, N, Seq...> {
+		using type = integer_sequence<I, Seq...>;
+	};
+}
+
+template<typename I, I N>
+using make_integer_sequence = typename _make_seq::helper<I, 0, N>::type;
+
+template<size_t N>
+using make_index_sequence = make_integer_sequence<size_t, N>;
+
+template<typename... T>
+using index_sequence_for = make_index_sequence<sizeof...(T)>;
+
+} // namespace std
+
+#endif // _CXXSHIM_UTILITY
diff --git a/mlibc/subprojects/cxxshim/std-coroutine/include/coroutine b/mlibc/subprojects/cxxshim/std-coroutine/include/coroutine
new file mode 100644
index 0000000..f58638c
--- /dev/null
+++ b/mlibc/subprojects/cxxshim/std-coroutine/include/coroutine
@@ -0,0 +1,90 @@
+#ifndef _CXXSHIM_COROUTINE
+#define _CXXSHIM_COROUTINE
+
+namespace std {
+
+template<typename ReturnType, typename... Args>
+struct coroutine_traits {
+    using promise_type = typename ReturnType::promise_type;
+};
+
+template<typename Promise = void>
+struct coroutine_handle;
+
+template<>
+struct coroutine_handle<void> {
+    template<typename Promise>
+    friend struct coroutine_handle;
+
+    static coroutine_handle<> from_address(void *frame) {
+        return coroutine_handle<>{frame};
+    }
+
+	coroutine_handle()
+	: _frame{nullptr} { }
+
+	explicit operator bool () {
+		return _frame;
+	}
+
+    void *address() {
+        return _frame;
+    }
+
+    bool done() {
+        return __builtin_coro_done(_frame);
+    }
+
+    void resume() {
+        __builtin_coro_resume(_frame);
+    }
+
+    void destroy() {
+        __builtin_coro_destroy(_frame);
+    }
+
+    void operator() () {
+        resume();
+    }
+
+private:
+    explicit coroutine_handle(void *frame)
+    : _frame{frame} { }
+
+    void *_frame;
+};
+
+template<typename Promise>
+struct coroutine_handle : coroutine_handle<> {
+	coroutine_handle() = default;
+
+    static coroutine_handle<Promise> from_promise(Promise &p) {
+        auto frame = __builtin_coro_promise(&p, alignof(Promise), true);
+        return coroutine_handle{frame};
+    }
+
+    Promise &promise() {
+        auto p_ptr = __builtin_coro_promise(_frame, alignof(Promise), false);
+        return *static_cast<Promise *>(p_ptr);
+    }
+
+private:
+    explicit coroutine_handle(void *frame)
+    : coroutine_handle<>{frame} { }
+};
+
+struct suspend_never {
+    bool await_ready() const { return true; }
+    void await_suspend(coroutine_handle<>) const {}
+    void await_resume() const {}
+};
+
+struct suspend_always {
+    bool await_ready() const { return false; }
+    void await_suspend(coroutine_handle<>) const {}
+    void await_resume() const {}
+};
+
+} // namespace std
+
+#endif // _CXXSHIM_COROUTINE
diff --git a/mlibc/subprojects/frigg/.git/HEAD b/mlibc/subprojects/frigg/.git/HEAD
new file mode 100644
index 0000000..cb089cd
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/HEAD
@@ -0,0 +1 @@
+ref: refs/heads/master
diff --git a/mlibc/subprojects/frigg/.git/config b/mlibc/subprojects/frigg/.git/config
new file mode 100644
index 0000000..8225b92
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/config
@@ -0,0 +1,11 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = false
+	logallrefupdates = true
+[remote "origin"]
+	url = https://github.com/managarm/frigg.git
+	fetch = +refs/heads/*:refs/remotes/origin/*
+[branch "master"]
+	remote = origin
+	merge = refs/heads/master
diff --git a/mlibc/subprojects/frigg/.git/description b/mlibc/subprojects/frigg/.git/description
new file mode 100644
index 0000000..498b267
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/description
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff --git a/mlibc/subprojects/frigg/.git/hooks/applypatch-msg.sample b/mlibc/subprojects/frigg/.git/hooks/applypatch-msg.sample
new file mode 100755
index 0000000..a5d7b84
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/hooks/applypatch-msg.sample
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
+:
diff --git a/mlibc/subprojects/frigg/.git/hooks/commit-msg.sample b/mlibc/subprojects/frigg/.git/hooks/commit-msg.sample
new file mode 100755
index 0000000..b58d118
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/hooks/commit-msg.sample
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff --git a/mlibc/subprojects/frigg/.git/hooks/fsmonitor-watchman.sample b/mlibc/subprojects/frigg/.git/hooks/fsmonitor-watchman.sample
new file mode 100755
index 0000000..14ed0aa
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/hooks/fsmonitor-watchman.sample
@@ -0,0 +1,173 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use IPC::Open2;
+
+# An example hook script to integrate Watchman
+# (https://facebook.github.io/watchman/) with git to speed up detecting
+# new and modified files.
+#
+# The hook is passed a version (currently 2) and last update token
+# formatted as a string and outputs to stdout a new update token and
+# all files that have been modified since the update token. Paths must
+# be relative to the root of the working tree and separated by a single NUL.
+#
+# To enable this hook, rename this file to "query-watchman" and set
+# 'git config core.fsmonitor .git/hooks/query-watchman'
+#
+my ($version, $last_update_token) = @ARGV;
+
+# Uncomment for debugging
+# print STDERR "$0 $version $last_update_token\n";
+
+# Check the hook interface version
+if ($version ne 2) {
+	die "Unsupported query-fsmonitor hook version '$version'.\n" .
+	    "Falling back to scanning...\n";
+}
+
+my $git_work_tree = get_working_dir();
+
+my $retry = 1;
+
+my $json_pkg;
+eval {
+	require JSON::XS;
+	$json_pkg = "JSON::XS";
+	1;
+} or do {
+	require JSON::PP;
+	$json_pkg = "JSON::PP";
+};
+
+launch_watchman();
+
+sub launch_watchman {
+	my $o = watchman_query();
+	if (is_work_tree_watched($o)) {
+		output_result($o->{clock}, @{$o->{files}});
+	}
+}
+
+sub output_result {
+	my ($clockid, @files) = @_;
+
+	# Uncomment for debugging watchman output
+	# open (my $fh, ">", ".git/watchman-output.out");
+	# binmode $fh, ":utf8";
+	# print $fh "$clockid\n@files\n";
+	# close $fh;
+
+	binmode STDOUT, ":utf8";
+	print $clockid;
+	print "\0";
+	local $, = "\0";
+	print @files;
+}
+
+sub watchman_clock {
+	my $response = qx/watchman clock "$git_work_tree"/;
+	die "Failed to get clock id on '$git_work_tree'.\n" .
+		"Falling back to scanning...\n" if $? != 0;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub watchman_query {
+	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
+	or die "open2() failed: $!\n" .
+	"Falling back to scanning...\n";
+
+	# In the query expression below we're asking for names of files that
+	# changed since $last_update_token but not from the .git folder.
+	#
+	# To accomplish this, we're using the "since" generator to use the
+	# recency index to select candidate nodes and "fields" to limit the
+	# output to file names only. Then we're using the "expression" term to
+	# further constrain the results.
+	if (substr($last_update_token, 0, 1) eq "c") {
+		$last_update_token = "\"$last_update_token\"";
+	}
+	my $query = <<"	END";
+		["query", "$git_work_tree", {
+			"since": $last_update_token,
+			"fields": ["name"],
+			"expression": ["not", ["dirname", ".git"]]
+		}]
+	END
+
+	# Uncomment for debugging the watchman query
+	# open (my $fh, ">", ".git/watchman-query.json");
+	# print $fh $query;
+	# close $fh;
+
+	print CHLD_IN $query;
+	close CHLD_IN;
+	my $response = do {local $/; <CHLD_OUT>};
+
+	# Uncomment for debugging the watch response
+	# open ($fh, ">", ".git/watchman-response.json");
+	# print $fh $response;
+	# close $fh;
+
+	die "Watchman: command returned no output.\n" .
+	"Falling back to scanning...\n" if $response eq "";
+	die "Watchman: command returned invalid output: $response\n" .
+	"Falling back to scanning...\n" unless $response =~ /^\{/;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub is_work_tree_watched {
+	my ($output) = @_;
+	my $error = $output->{error};
+	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
+		$retry--;
+		my $response = qx/watchman watch "$git_work_tree"/;
+		die "Failed to make watchman watch '$git_work_tree'.\n" .
+		    "Falling back to scanning...\n" if $? != 0;
+		$output = $json_pkg->new->utf8->decode($response);
+		$error = $output->{error};
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		# Uncomment for debugging watchman output
+		# open (my $fh, ">", ".git/watchman-output.out");
+		# close $fh;
+
+		# Watchman will always return all files on the first query so
+		# return the fast "everything is dirty" flag to git and do the
+		# Watchman query just to get it over with now so we won't pay
+		# the cost in git to look up each individual file.
+		my $o = watchman_clock();
+		$error = $output->{error};
+
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		output_result($o->{clock}, ("/"));
+		$last_update_token = $o->{clock};
+
+		eval { launch_watchman() };
+		return 0;
+	}
+
+	die "Watchman: $error.\n" .
+	"Falling back to scanning...\n" if $error;
+
+	return 1;
+}
+
+sub get_working_dir {
+	my $working_dir;
+	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+		$working_dir = Win32::GetCwd();
+		$working_dir =~ tr/\\/\//;
+	} else {
+		require Cwd;
+		$working_dir = Cwd::cwd();
+	}
+
+	return $working_dir;
+}
diff --git a/mlibc/subprojects/frigg/.git/hooks/post-update.sample b/mlibc/subprojects/frigg/.git/hooks/post-update.sample
new file mode 100755
index 0000000..ec17ec1
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/hooks/post-update.sample
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff --git a/mlibc/subprojects/frigg/.git/hooks/pre-applypatch.sample b/mlibc/subprojects/frigg/.git/hooks/pre-applypatch.sample
new file mode 100755
index 0000000..4142082
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/hooks/pre-applypatch.sample
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+precommit="$(git rev-parse --git-path hooks/pre-commit)"
+test -x "$precommit" && exec "$precommit" ${1+"$@"}
+:
diff --git a/mlibc/subprojects/frigg/.git/hooks/pre-commit.sample b/mlibc/subprojects/frigg/.git/hooks/pre-commit.sample
new file mode 100755
index 0000000..e144712
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/hooks/pre-commit.sample
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=$(git hash-object -t tree /dev/null)
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --type=bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff --git a/mlibc/subprojects/frigg/.git/hooks/pre-merge-commit.sample b/mlibc/subprojects/frigg/.git/hooks/pre-merge-commit.sample
new file mode 100755
index 0000000..399eab1
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/hooks/pre-merge-commit.sample
@@ -0,0 +1,13 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git merge" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message to
+# stderr if it wants to stop the merge commit.
+#
+# To enable this hook, rename this file to "pre-merge-commit".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+        exec "$GIT_DIR/hooks/pre-commit"
+:
diff --git a/mlibc/subprojects/frigg/.git/hooks/pre-push.sample b/mlibc/subprojects/frigg/.git/hooks/pre-push.sample
new file mode 100755
index 0000000..6187dbf
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/hooks/pre-push.sample
@@ -0,0 +1,53 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local sha1> <remote ref> <remote sha1>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+z40=0000000000000000000000000000000000000000
+
+while read local_ref local_sha remote_ref remote_sha
+do
+	if [ "$local_sha" = $z40 ]
+	then
+		# Handle delete
+		:
+	else
+		if [ "$remote_sha" = $z40 ]
+		then
+			# New branch, examine all commits
+			range="$local_sha"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_sha..$local_sha"
+		fi
+
+		# Check for WIP commit
+		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
+		if [ -n "$commit" ]
+		then
+			echo >&2 "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff --git a/mlibc/subprojects/frigg/.git/hooks/pre-rebase.sample b/mlibc/subprojects/frigg/.git/hooks/pre-rebase.sample
new file mode 100755
index 0000000..6cbef5c
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/hooks/pre-rebase.sample
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up to date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+<<\DOC_END
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
+
+DOC_END
diff --git a/mlibc/subprojects/frigg/.git/hooks/pre-receive.sample b/mlibc/subprojects/frigg/.git/hooks/pre-receive.sample
new file mode 100755
index 0000000..a1fd29e
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/hooks/pre-receive.sample
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to make use of push options.
+# The example simply echoes all push options that start with 'echoback='
+# and rejects all pushes when the "reject" push option is used.
+#
+# To enable this hook, rename this file to "pre-receive".
+
+if test -n "$GIT_PUSH_OPTION_COUNT"
+then
+	i=0
+	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
+	do
+		eval "value=\$GIT_PUSH_OPTION_$i"
+		case "$value" in
+		echoback=*)
+			echo "echo from the pre-receive-hook: ${value#*=}" >&2
+			;;
+		reject)
+			exit 1
+		esac
+		i=$((i + 1))
+	done
+fi
diff --git a/mlibc/subprojects/frigg/.git/hooks/prepare-commit-msg.sample b/mlibc/subprojects/frigg/.git/hooks/prepare-commit-msg.sample
new file mode 100755
index 0000000..10fa14c
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/hooks/prepare-commit-msg.sample
@@ -0,0 +1,42 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples. The first one removes the
+# "# Please enter the commit message..." help message.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+COMMIT_MSG_FILE=$1
+COMMIT_SOURCE=$2
+SHA1=$3
+
+/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
+
+# case "$COMMIT_SOURCE,$SHA1" in
+#  ,|template,)
+#    /usr/bin/perl -i.bak -pe '
+#       print "\n" . `git diff --cached --name-status -r`
+# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
+#  *) ;;
+# esac
+
+# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
+# if test -z "$COMMIT_SOURCE"
+# then
+#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
+# fi
diff --git a/mlibc/subprojects/frigg/.git/hooks/update.sample b/mlibc/subprojects/frigg/.git/hooks/update.sample
new file mode 100755
index 0000000..5014c4b
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/hooks/update.sample
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to block unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --type=bool hooks.allowunannotated)
+allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
+allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
+allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero="0000000000000000000000000000000000000000"
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
diff --git a/mlibc/subprojects/frigg/.git/index b/mlibc/subprojects/frigg/.git/index
new file mode 100644
index 0000000..a88be74
Binary files /dev/null and b/mlibc/subprojects/frigg/.git/index differ
diff --git a/mlibc/subprojects/frigg/.git/info/exclude b/mlibc/subprojects/frigg/.git/info/exclude
new file mode 100644
index 0000000..a5196d1
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/info/exclude
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff --git a/mlibc/subprojects/frigg/.git/logs/HEAD b/mlibc/subprojects/frigg/.git/logs/HEAD
new file mode 100644
index 0000000..c1917a6
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/logs/HEAD
@@ -0,0 +1,2 @@
+0000000000000000000000000000000000000000 070aadc38552f226c64a015f050618a48918584f mintsuki <mintsuki@protonmail.com> 1602036086 +0200	clone: from https://github.com/managarm/frigg.git
+070aadc38552f226c64a015f050618a48918584f 070aadc38552f226c64a015f050618a48918584f mintsuki <mintsuki@protonmail.com> 1602036086 +0200	checkout: moving from master to master
diff --git a/mlibc/subprojects/frigg/.git/logs/refs/heads/master b/mlibc/subprojects/frigg/.git/logs/refs/heads/master
new file mode 100644
index 0000000..1cda05c
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/logs/refs/heads/master
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 070aadc38552f226c64a015f050618a48918584f mintsuki <mintsuki@protonmail.com> 1602036086 +0200	clone: from https://github.com/managarm/frigg.git
diff --git a/mlibc/subprojects/frigg/.git/logs/refs/remotes/origin/HEAD b/mlibc/subprojects/frigg/.git/logs/refs/remotes/origin/HEAD
new file mode 100644
index 0000000..1cda05c
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/logs/refs/remotes/origin/HEAD
@@ -0,0 +1 @@
+0000000000000000000000000000000000000000 070aadc38552f226c64a015f050618a48918584f mintsuki <mintsuki@protonmail.com> 1602036086 +0200	clone: from https://github.com/managarm/frigg.git
diff --git a/mlibc/subprojects/frigg/.git/objects/pack/pack-3a00b324fe716c2400f2d8eb2ad9664cbedec4d7.idx b/mlibc/subprojects/frigg/.git/objects/pack/pack-3a00b324fe716c2400f2d8eb2ad9664cbedec4d7.idx
new file mode 100644
index 0000000..88032c7
Binary files /dev/null and b/mlibc/subprojects/frigg/.git/objects/pack/pack-3a00b324fe716c2400f2d8eb2ad9664cbedec4d7.idx differ
diff --git a/mlibc/subprojects/frigg/.git/objects/pack/pack-3a00b324fe716c2400f2d8eb2ad9664cbedec4d7.pack b/mlibc/subprojects/frigg/.git/objects/pack/pack-3a00b324fe716c2400f2d8eb2ad9664cbedec4d7.pack
new file mode 100644
index 0000000..299f0b2
Binary files /dev/null and b/mlibc/subprojects/frigg/.git/objects/pack/pack-3a00b324fe716c2400f2d8eb2ad9664cbedec4d7.pack differ
diff --git a/mlibc/subprojects/frigg/.git/packed-refs b/mlibc/subprojects/frigg/.git/packed-refs
new file mode 100644
index 0000000..0f5ce13
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/packed-refs
@@ -0,0 +1,3 @@
+# pack-refs with: peeled fully-peeled sorted 
+5a60f014709b6fb61734e7e6ad0cc092fd9548d7 refs/remotes/origin/default_alloc
+070aadc38552f226c64a015f050618a48918584f refs/remotes/origin/master
diff --git a/mlibc/subprojects/frigg/.git/refs/heads/master b/mlibc/subprojects/frigg/.git/refs/heads/master
new file mode 100644
index 0000000..8e9069f
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/refs/heads/master
@@ -0,0 +1 @@
+070aadc38552f226c64a015f050618a48918584f
diff --git a/mlibc/subprojects/frigg/.git/refs/remotes/origin/HEAD b/mlibc/subprojects/frigg/.git/refs/remotes/origin/HEAD
new file mode 100644
index 0000000..6efe28f
--- /dev/null
+++ b/mlibc/subprojects/frigg/.git/refs/remotes/origin/HEAD
@@ -0,0 +1 @@
+ref: refs/remotes/origin/master
diff --git a/mlibc/subprojects/frigg/LICENSE b/mlibc/subprojects/frigg/LICENSE
new file mode 100644
index 0000000..ee680a9
--- /dev/null
+++ b/mlibc/subprojects/frigg/LICENSE
@@ -0,0 +1,7 @@
+Copyright 2014-2020 Frigg Contributors
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/mlibc/subprojects/frigg/include/frg/allocation.hpp b/mlibc/subprojects/frigg/include/frg/allocation.hpp
new file mode 100644
index 0000000..515f478
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/allocation.hpp
@@ -0,0 +1,95 @@
+#ifndef FRG_ALLOCATION_HPP
+#define FRG_ALLOCATION_HPP
+
+#include <new>
+#include <utility>
+
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename T, typename Allocator, typename... Args>
+T *construct(Allocator &allocator, Args &&... args) {
+	void *pointer = allocator.allocate(sizeof(T));
+	return new(pointer) T(std::forward<Args>(args)...);
+}
+template<typename T, typename Allocator, typename... Args>
+T *construct_n(Allocator &allocator, size_t n, Args &&... args) {
+	T *pointer = (T *)allocator.allocate(sizeof(T) * n);
+	for(size_t i = 0; i < n; i++)
+		new(&pointer[i]) T(std::forward<Args>(args)...);
+	return pointer;
+}
+
+template<typename T, typename Allocator>
+void destruct(Allocator &allocator, T *pointer) {
+	if(!pointer)
+		return;
+	pointer->~T();
+	allocator.deallocate(pointer, sizeof(T));
+}
+
+template<typename T, typename Allocator>
+void destruct_n(Allocator &allocator, T *pointer, size_t n) {
+	if(!pointer)
+		return;
+	for(size_t i = 0; i < n; i++)
+		pointer[i].~T();
+	allocator.deallocate(pointer, sizeof(T) * n);
+}
+
+template<typename Allocator>
+struct unique_memory {
+	friend void swap(unique_memory &a, unique_memory &b) {
+		using std::swap;
+		swap(a.pointer_, b.pointer_);
+		swap(a.size_, b.size_);
+		swap(a.allocator_, b.allocator_);
+	}
+
+	unique_memory()
+	: pointer_{nullptr}, size_{0}, allocator_{nullptr} { }
+
+	explicit unique_memory(Allocator &allocator, size_t size)
+	: size_{size}, allocator_{&allocator} {
+		pointer_ = allocator_->allocate(size);
+	}
+
+	unique_memory(unique_memory &&other)
+	: unique_memory{} {
+		swap(*this, other);
+	}
+
+	unique_memory(const unique_memory &other) = delete;
+
+	~unique_memory() {
+		if(pointer_)
+			allocator_->free(pointer_);
+	}
+
+	explicit operator bool () {
+		return pointer_;
+	}
+
+	unique_memory &operator= (unique_memory other) {
+		swap(*this, other);
+		return *this;
+	}
+
+	void *data() const {
+		return pointer_;
+	}
+
+	size_t size() const {
+		return size_;
+	}
+
+private:
+	void *pointer_;
+	size_t size_;
+	Allocator *allocator_;
+};
+
+} // namespace frg
+
+#endif // FRG_ALLOCATION_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/array.hpp b/mlibc/subprojects/frigg/include/frg/array.hpp
new file mode 100644
index 0000000..df00036
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/array.hpp
@@ -0,0 +1,166 @@
+#ifndef FRG_ARRAY_HPP
+#define FRG_ARRAY_HPP
+
+#include <stddef.h>
+#include <utility>
+#include <type_traits>
+#include <tuple>
+
+namespace frg {
+
+template<class T, size_t N>
+class array {
+public:
+	using value_type = T;
+	using size_type = size_t;
+	using reference = value_type&;
+	using const_reference = const value_type&;
+	using pointer = value_type*;
+	using const_pointer = const value_type*;
+	using iterator = pointer;
+	using const_iterator = const_pointer;
+	// the actual array
+	value_type _stor[N];
+
+	friend void swap(array &a, array &b) {
+	    for (size_t i = 0; i < N; i++)
+		std::swap(a._stor[i], b._stor[i]);
+	}
+
+	constexpr reference operator[](size_type pos) {
+		return _stor[pos];
+	}
+	constexpr const_reference operator[](size_type pos) const {
+		return _stor[pos];
+	}
+
+	constexpr reference front() {
+		return _stor[0];
+	}
+	constexpr const_reference front() const {
+		return _stor[0];
+	}
+
+	constexpr reference back() {
+		return _stor[N];
+	}
+	constexpr const_reference back() const {
+		return _stor[N];
+	}
+
+	constexpr iterator begin() noexcept {
+		return &_stor[0];
+	}
+	constexpr const_iterator begin() const noexcept {
+		return &_stor[0];
+	}
+	constexpr const_iterator cbegin() const noexcept {
+		return &_stor[0];
+	}
+
+	constexpr iterator end() noexcept {
+		return &_stor[N];
+	}
+	constexpr const_iterator end() const noexcept {
+		return &_stor[N];
+	}
+	constexpr const_iterator cend() const noexcept {
+		return &_stor[N];
+	}
+
+	constexpr T* data() noexcept {
+		return &_stor[0];
+	}
+	constexpr T* data() const noexcept {
+		return &_stor[0];
+	}
+
+	constexpr bool empty() const noexcept {
+		return N == 0;
+	}
+
+	constexpr size_type size() const noexcept {
+		return N;
+	}
+
+	constexpr size_type max_size() const noexcept {
+		// for arrays it is equal to size()
+		return N;
+	}
+};
+
+namespace details {
+	template<typename ...Ts>
+	struct concat_size;
+
+	template<typename ...Ts>
+	inline constexpr size_t concat_size_v = concat_size<Ts...>::value;
+
+	template<typename T, typename ...Ts>
+	struct concat_size<T, Ts...>
+	: std::integral_constant<size_t, std::tuple_size_v<T> + concat_size_v<Ts...>> { };
+
+	template<>
+	struct concat_size<>
+	: std::integral_constant<size_t, 0> { };
+
+	template<typename X, size_t N>
+	constexpr void concat_insert(frg::array<X, N> &, size_t) { }
+
+	template<typename X, size_t N, typename T, typename... Ts>
+	constexpr void concat_insert(frg::array<X, N> &res, size_t at, const T &other, const Ts &...tail) {
+		size_t n = std::tuple_size_v<T>;
+		for(size_t i = 0; i < n; ++i)
+			res[at + i] = other[i];
+		concat_insert(res, at + n, tail...);
+	}
+} // namespace details
+
+template<typename X, typename ...Ts>
+constexpr auto array_concat(const Ts &...arrays) {
+	frg::array<X, details::concat_size_v<Ts...>> res{};
+	details::concat_insert(res, 0, arrays...);
+	return res;
+}
+
+} // namespace frg
+
+namespace std {
+
+template<size_t I, class T, size_t N>
+constexpr T &get(frg::array<T, N> &a) noexcept {
+	static_assert(I < N, "array index is not within bounds");
+	return a[I];
+};
+
+template<size_t I, class T, size_t N>
+constexpr T &&get(frg::array<T, N> &&a) noexcept {
+	static_assert(I < N, "array index is not within bounds");
+	return std::move(a[I]);
+};
+
+template<size_t I, class T, size_t N>
+constexpr const T &get(const frg::array<T, N> &a) noexcept {
+	static_assert(I < N, "array index is not within bounds");
+	return a[I];
+};
+
+template<size_t I, class T, size_t N>
+constexpr const T &&get(const frg::array<T, N> &&a) noexcept {
+	static_assert(I < N, "array index is not within bounds");
+	return std::move(a[I]);
+};
+
+template<class T, size_t N>
+struct tuple_size<frg::array<T, N>> :
+    integral_constant<size_t, N>
+{ };
+
+template<size_t I, class T, size_t N>
+struct tuple_element<I, frg::array<T, N>> {
+	using type = T;
+};
+
+} // namespace std
+
+#endif // FRG_ARRAY_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/container_of.hpp b/mlibc/subprojects/frigg/include/frg/container_of.hpp
new file mode 100644
index 0000000..533578b
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/container_of.hpp
@@ -0,0 +1,22 @@
+#ifndef FRG_CONTAINER_OF_HPP
+#define FRG_CONTAINER_OF_HPP
+
+#include <stdint.h>
+#include <string.h>
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename T, typename C>
+C *container_of(T *p, T C::*mptr) {
+	static_assert(sizeof(T C::*) == sizeof(uintptr_t), "Broken ABI");
+
+	uintptr_t offset;
+	memcpy(&offset, &mptr, sizeof(uintptr_t));
+	auto r = reinterpret_cast<char *>(p);
+	return reinterpret_cast<C *>(r - offset);
+}
+
+} // namespace frg
+
+#endif // FRG_CONTAINER_OF_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/detection.hpp b/mlibc/subprojects/frigg/include/frg/detection.hpp
new file mode 100644
index 0000000..e55e526
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/detection.hpp
@@ -0,0 +1,22 @@
+#pragma once
+
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename... Ts>
+using void_t = void;
+
+template <template <typename...> typename Trait, typename Void, typename... Args>
+struct is_detected_helper : std::false_type { };
+
+template <template <typename...> typename Trait, typename... Args>
+struct is_detected_helper<Trait, void_t<Trait<Args...>>, Args...> : std::true_type { };
+
+template <template <typename...> typename Trait, typename... Args>
+constexpr bool is_detected_v = is_detected_helper<Trait, void, Args...>::value;
+
+template<typename... Ts>
+constexpr bool dependent_false_t = false;
+
+} // namespace frg
diff --git a/mlibc/subprojects/frigg/include/frg/eternal.hpp b/mlibc/subprojects/frigg/include/frg/eternal.hpp
new file mode 100644
index 0000000..eee909b
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/eternal.hpp
@@ -0,0 +1,50 @@
+#ifndef FRG_ETERNAL_HPP
+#define FRG_ETERNAL_HPP
+
+#include <new>
+#include <utility>
+#include <algorithm>
+
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<size_t Size, size_t Align>
+struct alignas(Align) aligned_storage {
+	constexpr aligned_storage()
+	: buffer{0} { }
+
+	char buffer[Size];
+};
+
+template <typename ...T>
+using aligned_union = aligned_storage<
+	std::max({sizeof(T)...}),
+	std::max({alignof(T)...})
+>;
+
+// Container for an object that deletes the object's destructor.
+// eternal<T> always has a trivial destructor.
+template<typename T>
+class eternal {
+public:
+	static_assert(__has_trivial_destructor(aligned_storage<sizeof(T), alignof(T)>),
+			"eternal<T> should have a trivial destructor");
+
+	template<typename... Args>
+	eternal(Args &&... args) {
+		new (&_storage) T(std::forward<Args>(args)...);
+	}
+
+	T &get() {
+		return *reinterpret_cast<T *>(&_storage);
+	}
+
+private:
+	aligned_storage<sizeof(T), alignof(T)> _storage;
+};
+
+} // namespace frg
+
+#endif // FRG_ETERNAL_HPP
+
diff --git a/mlibc/subprojects/frigg/include/frg/expected.hpp b/mlibc/subprojects/frigg/include/frg/expected.hpp
new file mode 100644
index 0000000..e600375
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/expected.hpp
@@ -0,0 +1,247 @@
+#pragma once
+
+#include <new>
+#include <utility>
+
+#include <frg/macros.hpp>
+
+#define FRG_TRY(expr) ({ \
+    auto ex = (expr); \
+    if(!ex) \
+        return ex.error(); \
+    value_or_void(ex); \
+})
+
+#define FRG_CO_TRY(expr) ({ \
+    auto ex = (expr); \
+    if(!ex) \
+        co_return ex.error(); \
+    value_or_void(ex); \
+})
+
+namespace frg {
+
+struct success_tag { };
+
+inline constexpr success_tag success;
+
+// Contextually convert to bool but also handle enum classes.
+template<typename E>
+bool indicates_error(E v) {
+	return v != E{};
+}
+
+// Conditionally add a non-trivial destructor.
+// This should probably work with requires clauses on ~expected()
+// but on Clang 10, it does not.
+template<typename E, typename T>
+struct destructor_crtp;
+
+template<typename E, typename T = void>
+struct [[nodiscard]] expected : destructor_crtp<E, T> {
+	static_assert(std::is_default_constructible_v<E>
+			&& std::is_trivially_copy_constructible_v<E>
+			&& std::is_trivially_move_constructible_v<E>
+			&& std::is_trivially_destructible_v<E>);
+	static_assert(!std::is_convertible_v<E, T> && !std::is_convertible_v<T, E>);
+
+	friend struct destructor_crtp<E, T>;
+
+    expected()
+	requires (std::is_default_constructible_v<T>)
+    : e_{} {
+        FRG_ASSERT(!indicates_error(e_));
+        new (stor_) T{};
+    }
+
+	expected(const expected &other)
+	requires (std::is_trivially_copy_constructible_v<T>)
+	= default;
+
+	expected(const expected &other)
+	requires (!std::is_trivially_copy_constructible_v<T>)
+	: e_{other.e_} {
+		if(!indicates_error(e_))
+			new (stor_) T{*std::launder(reinterpret_cast<T *>(other.stor_))};
+	}
+
+	expected(expected &&other)
+	requires (std::is_trivially_move_constructible_v<T>)
+	= default;
+
+	expected(expected &&other)
+	requires (!std::is_trivially_move_constructible_v<T>)
+	: e_{other.e_} {
+		if(!indicates_error(e_))
+			new (stor_) T{std::move(*std::launder(reinterpret_cast<T *>(other.stor_)))};
+	}
+
+    expected(success_tag)
+	requires (std::is_default_constructible_v<T>)
+    : e_{} {
+        FRG_ASSERT(!indicates_error(e_));
+        new (stor_) T{};
+    }
+
+    expected(E e)
+    : e_{e} {
+        FRG_ASSERT(indicates_error(e));
+    }
+
+    expected(T val)
+    : e_{} {
+        FRG_ASSERT(!indicates_error(e_));
+        new (stor_) T{std::move(val)};
+    }
+
+	expected &operator= (const expected &other)
+	requires (std::is_trivially_copy_assignable_v<T>)
+	= default;
+
+	expected &operator= (const expected &other)
+	requires (!std::is_trivially_copy_assignable_v<T>) {
+		if(indicates_error(other.e_)) {
+			T temp{*std::launder(reinterpret_cast<T *>(other.stor_))};
+			if(!indicates_error(e_))
+				std::launder(reinterpret_cast<T *>(stor_))->~T();
+			e_ = other.e_;
+			new (stor_) T{std::move(temp)};
+		}else{
+			if(!indicates_error(e_))
+				std::launder(reinterpret_cast<T *>(stor_))->~T();
+			e_ = other.e_;
+		}
+	}
+
+	expected &operator= (expected &&other)
+	requires (std::is_trivially_move_assignable_v<T>)
+	= default;
+
+	expected &operator= (expected &&other)
+	requires (!std::is_trivially_move_assignable_v<T>) {
+		if(indicates_error(other.e_)) {
+			T temp{std::move(*std::launder(reinterpret_cast<T *>(other.stor_)))};
+			if(!indicates_error(e_))
+				std::launder(reinterpret_cast<T *>(stor_))->~T();
+			e_ = other.e_;
+			new (stor_) T{std::move(temp)};
+		}else{
+			if(!indicates_error(e_))
+				std::launder(reinterpret_cast<T *>(stor_))->~T();
+			e_ = other.e_;
+		}
+		return *this;
+	}
+
+    explicit operator bool () const {
+        return !indicates_error(e_);
+    }
+
+	E maybe_error() const {
+		return e_;
+	}
+
+    E error() const {
+        FRG_ASSERT(indicates_error(e_));
+        return e_;
+    }
+
+    T &value() {
+        FRG_ASSERT(!indicates_error(e_));
+        return *std::launder(reinterpret_cast<T *>(stor_));
+    }
+
+    const T &value() const {
+        FRG_ASSERT(!indicates_error(e_));
+        return *std::launder(reinterpret_cast<const T *>(stor_));
+    }
+
+    template<typename F>
+    expected<E, std::invoke_result_t<F, T>> map(F fun) {
+        if((*this))
+            return fun(std::move(value()));
+        return error();
+    }
+
+    template<typename F>
+    expected<std::invoke_result_t<F, E>, T> map_error(F fun) {
+        if(!(*this))
+            return fun(error());
+        return std::move(value());
+    }
+
+private:
+    alignas(alignof(T)) char stor_[sizeof(T)];
+    E e_;
+};
+
+template<typename E, typename T>
+requires (std::is_trivially_destructible_v<T>)
+struct destructor_crtp<E, T> { };
+
+template<typename E, typename T>
+requires (!std::is_trivially_destructible_v<T>)
+struct destructor_crtp<E, T> {
+	~destructor_crtp() {
+		auto self = static_cast<expected<E, T> *>(this);
+		if(!indicates_error(self->e_)) {
+			auto p = std::launder(reinterpret_cast<T *>(self->stor_));
+			p->~T();
+		}
+	}
+};
+
+template<typename E>
+struct [[nodiscard]] expected<E, void> {
+	static_assert(std::is_default_constructible_v<E>
+			&& std::is_trivially_copy_constructible_v<E>
+			&& std::is_trivially_move_constructible_v<E>
+			&& std::is_trivially_destructible_v<E>);
+
+    expected()
+    : e_{} {
+        FRG_ASSERT(!indicates_error(e_));
+    }
+
+    expected(success_tag)
+    : e_{} {
+        FRG_ASSERT(!indicates_error(e_));
+    }
+
+    expected(E e)
+    : e_{e} {
+        FRG_ASSERT(indicates_error(e));
+    }
+
+    explicit operator bool () const {
+        return !indicates_error(e_);
+    }
+
+	E maybe_error() const {
+		return e_;
+	}
+
+    E error() const {
+        FRG_ASSERT(indicates_error(e_));
+        return e_;
+    }
+
+    template<typename F>
+    expected<std::invoke_result_t<F, E>> map_error(F fun) {
+        if(!(*this))
+            return fun(error());
+        return {};
+    }
+
+private:
+    E e_;
+};
+
+// Helper function for the FRG_TRY macros.
+template<typename E, typename T>
+auto value_or_void(expected<E, T> &ex) {
+	if constexpr (requires { ex.value(); })
+		return ex.value();
+}
+
+} // namespace frg
diff --git a/mlibc/subprojects/frigg/include/frg/formatting.hpp b/mlibc/subprojects/frigg/include/frg/formatting.hpp
new file mode 100644
index 0000000..c539caa
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/formatting.hpp
@@ -0,0 +1,769 @@
+#ifndef FRG_FORMATTING_HPP
+#define FRG_FORMATTING_HPP
+
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+#include <frg/macros.hpp>
+#include <frg/optional.hpp>
+#include <frg/string.hpp>
+#include <frg/utility.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+// Concept: Formatter.
+// Supports a single operation: append().
+// append() is overloaded for a variety of types.
+
+// TODO: Does it make sense for this library to implement Formatters at all?
+// TODO: Or should we only implement the formatting itself?
+
+template<typename C, size_t Limit>
+struct limited_formatter {
+	limited_formatter()
+	: _off{0} { }
+
+	void append(C s) {
+		_buffer[_off++] = s;
+	}
+
+	void append(C *str) {
+		while(*str)
+			_buffer[_off++] = *str++;
+	}
+
+private:
+	C _buffer[Limit];
+	size_t _off;
+};
+
+// ----------------------------------------------------------------------------
+// General formatting machinery.
+// ----------------------------------------------------------------------------
+
+enum class format_conversion {
+	null,
+	decimal,
+	hex
+};
+
+struct format_options {
+	format_options()
+	: conversion{format_conversion::null} { }
+
+	format_options with_conversion(format_conversion c) {
+		auto copy = *this;
+		copy.conversion = c;
+		return copy;
+	}
+
+	format_conversion conversion;
+	int minimum_width = 0;
+	optional<int> precision;
+	bool left_justify = false;
+	bool always_sign = false;
+	bool plus_becomes_space = false;
+	bool alt_conversion = false;
+	bool fill_zeros = false;
+	bool group_thousands = false;
+};
+
+struct locale_options {
+	locale_options()
+	: decimal_point("."), thousands_sep(""), grouping("\255") { }
+
+	locale_options(const char *d_p, const char *t_s, const char *grp)
+	: decimal_point(d_p), thousands_sep(t_s), grouping(grp) {
+		thousands_sep_size = strlen(thousands_sep);
+	}
+
+	const char *decimal_point;
+	const char *thousands_sep;
+	const char *grouping;
+	size_t thousands_sep_size;
+};
+
+// ----------------------------------------------------------------------------
+// Formatting primitives for built-in types.
+// ----------------------------------------------------------------------------
+
+namespace _fmt_basics {
+	// width: Minimum width of the output (padded with spaces by default).
+	// precision: Minimum number of digits in the ouput (always padded with zeros).
+	template<typename P, typename T>
+	void print_digits(P &formatter, T number, bool negative, int radix,
+			int width, int precision, char padding, bool left_justify,
+			bool group_thousands, locale_options locale_opts) {
+		const char *digits = "0123456789abcdef";
+		char buffer[32];
+
+		int k = 0; // number of digits
+		int c = 0; // number of chars since last grouping
+		int g = 0; // grouping index
+		int r = 0; // amount of times we repeated the last grouping
+		size_t extra = 0; // extra chars printed due to seperator
+
+		auto step_grouping = [&] () {
+			if (!group_thousands)
+				return;
+
+			if (++c == locale_opts.grouping[g]) {
+				if (locale_opts.grouping[g + 1] > 0)
+					g++;
+				else
+					r++;
+				c = 0;
+				extra += locale_opts.thousands_sep_size;
+			}
+		};
+
+		auto emit_grouping = [&] () {
+			if (!group_thousands)
+				return;
+
+			if (--c == 0) {
+				formatter.append(locale_opts.thousands_sep);
+				if (!r || !--r)
+					g--;
+				c = locale_opts.grouping[g];
+			}
+		};
+
+		// print the number in reverse order and determine #digits.
+		do {
+			FRG_ASSERT(k < 32); // TODO: variable number of digits
+			buffer[k++] = digits[number % radix];
+			number /= radix;
+			step_grouping();
+		} while(number);
+
+		if (k < precision)
+			for (int i = 0; i < precision - k; i++)
+				step_grouping();
+
+		if (!c)
+			c = locale_opts.grouping[g];
+
+		int final_width = max(k, precision) + extra;
+
+		if(!left_justify && final_width < width)
+			for(int i = 0; i < width - final_width; i++)
+				formatter.append(padding);
+
+		if(negative)
+			formatter.append('-');
+
+		if(k < precision) {
+			for(int i = 0; i < precision - k; i++) {
+				formatter.append('0');
+				emit_grouping();
+			}
+		}
+
+		for(int i = k - 1; i >= 0; i--) {
+			formatter.append(buffer[i]);
+			emit_grouping();
+		}
+
+		if(left_justify && final_width < width)
+			for(int i = final_width; i < width; i++)
+				formatter.append(padding);
+	}
+
+	template<typename T>
+	struct make_unsigned;
+
+	template<> struct make_unsigned<int> { using type = unsigned int; };
+	template<> struct make_unsigned<unsigned int> { using type = unsigned int; };
+	template<> struct make_unsigned<long> { using type = unsigned long; };
+	template<> struct make_unsigned<unsigned long> { using type = unsigned long; };
+	template<> struct make_unsigned<long long> { using type = unsigned long long; };
+	template<> struct make_unsigned<unsigned long long> { using type = unsigned long long; };
+
+	// Signed integer formatting. We cannot print -x as that might not fit into the signed type.
+	// Strategy: Cast to unsigned first (i.e. obtain 2s complement) and negate manually by
+	// computing (~x + 1).
+	template<typename P, typename T>
+	void print_int(P &formatter, T number, int radix, int width = 0,
+			int precision = 1, char padding = ' ', bool left_justify = false,
+			bool group_thousands = false, locale_options locale_opts = {}) {
+		if(number < 0) {
+			auto absv = ~static_cast<typename make_unsigned<T>::type>(number) + 1;
+			print_digits(formatter, absv, true, radix, width, precision, padding,
+					left_justify, group_thousands, locale_opts);
+		}else{
+			print_digits(formatter, number, false, radix, width, precision, padding,
+					left_justify, group_thousands, locale_opts);
+		}
+	}
+
+	template<typename T, typename F>
+	void format_integer(T object, format_options fo, F &formatter) {
+		if(fo.conversion == format_conversion::hex) {
+			print_int(formatter, object, 16);
+		}else{
+			FRG_ASSERT(fo.conversion == format_conversion::null
+					|| fo.conversion == format_conversion::decimal);
+			print_int(formatter, object, 10);
+		}
+	}
+
+	template<typename P, typename T>
+	void print_float(P &formatter, T number, int width = 0, int precision = 6,
+			char padding = ' ', bool group_thousands = false,
+			locale_options locale_opts = {}) {
+		// TODO(geert): implement these
+		FRG_DEBUG_ASSERT(width == 0);
+		FRG_DEBUG_ASSERT(padding == ' ');
+
+		if (!precision)
+			precision = 6;
+
+		uint64_t n = static_cast<uint64_t>(number);
+		print_int(formatter, n, 10);
+		number -= n;
+
+		formatter.append(locale_opts.decimal_point);
+
+		number *= 10;
+		n = static_cast<uint64_t>(number);
+		number -= n;
+		int i = 0;
+		while (n > 0 && i < precision) {
+			formatter.append('0' + n);
+			number *= 10;
+			n = static_cast<uint64_t>(number);
+			number -= n;
+			i++;
+		}
+	}
+
+	template<typename T, typename F>
+	void format_float(T object, format_options fo, F &formatter) {
+		print_float(formatter, object, fo.minimum_width, fo.precision,
+				fo.fill_zeros ? '0' : ' ');
+	}
+};
+
+template<typename F>
+void format_object(unsigned int object, format_options fo, F &formatter) {
+	_fmt_basics::format_integer(object, fo, formatter);
+}
+
+template<typename F>
+void format_object(unsigned long object, format_options fo, F &formatter) {
+	_fmt_basics::format_integer(object, fo, formatter);
+}
+
+template<typename F>
+void format_object(unsigned long long object, format_options fo, F &formatter) {
+	_fmt_basics::format_integer(object, fo, formatter);
+}
+
+template<typename F>
+void format_object(int object, format_options fo, F &formatter) {
+	_fmt_basics::format_integer(object, fo, formatter);
+}
+
+template<typename F>
+void format_object(long object, format_options fo, F &formatter) {
+	_fmt_basics::format_integer(object, fo, formatter);
+}
+
+template<typename F>
+void format_object(long long object, format_options fo, F &formatter) {
+	_fmt_basics::format_integer(object, fo, formatter);
+}
+
+template<typename F>
+void format_object(float object, format_options fo, F &formatter) {
+	_fmt_basics::format_integer(object, fo, formatter);
+}
+
+template<typename F>
+void format_object(double object, format_options fo, F &formatter) {
+	_fmt_basics::format_integer(object, fo, formatter);
+}
+
+template<typename F>
+void format_object(const char *object, format_options fo, F &formatter) {
+	formatter.append(object);
+}
+
+template<typename F>
+void format_object(const frg::string_view &object, format_options fo, F &formatter) {
+	for(size_t i = 0; i < object.size(); ++i)
+		formatter.append(object[i]);
+}
+
+template<typename F, typename Allocator>
+void format_object(const frg::string<Allocator> &object, format_options fo, F &formatter) {
+	formatter.append(object.data());
+}
+
+template<typename F>
+void format_object(const void *object, format_options fo, F &formatter) {
+	formatter.append("0x");
+	_fmt_basics::format_integer(reinterpret_cast<uintptr_t>(object),
+			format_options{}.with_conversion(format_conversion::hex), formatter);
+}
+
+// ----------------------------------------------------------------------------
+
+struct va_struct {
+	va_list args;
+};
+
+enum class printf_size_mod {
+	default_size,
+	long_size,
+	longlong_size,
+	longdouble_size,
+	native_size
+};
+
+template<typename A>
+void printf_format(A agent, const char *s, va_struct *vsp) {
+	while(*s) {
+		if(*s != '%') {
+			size_t n = 1;
+			while(s[n] && s[n] != '%')
+				n++;
+			agent(s, n);
+			s += n;
+			continue;
+		}
+
+		++s;
+		FRG_ASSERT(*s);
+
+		if(*s == '%') {
+			agent('%');
+			++s;
+			continue;
+		}
+
+		format_options opts;
+		while(true) {
+			if(*s == '-') {
+				opts.left_justify = true;
+				++s;
+				FRG_ASSERT(*s);
+			}else if(*s == '+') {
+				opts.always_sign = true;
+				++s;
+				FRG_ASSERT(*s);
+			}else if(*s == ' ') {
+				opts.plus_becomes_space = true;
+				++s;
+				FRG_ASSERT(*s);
+			}else if(*s == '#') {
+				opts.alt_conversion = true;
+				++s;
+				FRG_ASSERT(*s);
+			}else if(*s == '0') {
+				opts.fill_zeros = true;
+				++s;
+				FRG_ASSERT(*s);
+			}else if(*s == '\'') {
+				opts.group_thousands = true;
+				++s;
+				FRG_ASSERT(*s);
+			}else{
+				break;
+			}
+		}
+
+		FRG_ASSERT(!opts.always_sign);
+		FRG_ASSERT(!opts.plus_becomes_space);
+
+		if(*s == '*') {
+			++s;
+			FRG_ASSERT(*s);
+			opts.minimum_width = va_arg(vsp->args, int);
+		}else{
+			int w = 0;
+			while(*s >= '0' && *s <= '9') {
+				w = w * 10 + (*s - '0');
+				++s;
+				FRG_ASSERT(*s);
+			}
+			opts.minimum_width = w;
+		}
+
+		if(*s == '.') {
+			++s;
+			FRG_ASSERT(*s);
+
+			if(*s == '*') {
+				++s;
+				FRG_ASSERT(*s);
+				opts.precision = va_arg(vsp->args, int);
+			}else{
+				int value = 0;
+				FRG_ASSERT(*s >= '0' && *s <= '9');
+				while(*s >= '0' && *s <= '9') {
+					value = value * 10 + (*s - '0');
+					++s;
+					FRG_ASSERT(*s);
+				}
+				opts.precision = value;
+			}
+		}
+
+		auto szmod = printf_size_mod::default_size;
+		if(*s == 'l') {
+			++s;
+			FRG_ASSERT(*s);
+			if(*s == 'l') {
+				szmod = printf_size_mod::longlong_size;
+				++s;
+				FRG_ASSERT(*s);
+			}else{
+				szmod = printf_size_mod::long_size;
+			}
+		}else if(*s == 'z') {
+			szmod = printf_size_mod::native_size;
+			++s;
+			FRG_ASSERT(*s);
+		} else if(*s == 'L') {
+			szmod = printf_size_mod::longdouble_size;
+			++s;
+			FRG_ASSERT(*s);
+		}
+
+		agent(*s, opts, szmod);
+		++s;
+	}
+}
+
+template<typename F>
+void do_printf_chars(F &formatter, char t, format_options opts,
+		printf_size_mod szmod, va_struct *vsp) {
+	switch(t) {
+	case 'p':
+		FRG_ASSERT(!opts.fill_zeros);
+		FRG_ASSERT(!opts.left_justify);
+		FRG_ASSERT(!opts.alt_conversion);
+		FRG_ASSERT(opts.minimum_width == 0);
+		formatter.append("0x");
+		_fmt_basics::print_int(formatter, (uintptr_t)va_arg(vsp->args, void *), 16);
+		break;
+	case 'c':
+		FRG_ASSERT(!opts.fill_zeros);
+		FRG_ASSERT(!opts.alt_conversion);
+		FRG_ASSERT(szmod == printf_size_mod::default_size);
+		FRG_ASSERT(!opts.precision);
+		if (opts.left_justify) {
+			formatter.append((char)va_arg(vsp->args, int));
+			for (int i = 0; i < opts.minimum_width - 1; i++)
+				formatter.append(' ');
+		} else {
+			for (int i = 0; i < opts.minimum_width - 1; i++)
+				formatter.append(' ');
+			formatter.append((char)va_arg(vsp->args, int));
+		}
+		break;
+	case 's': {
+		FRG_ASSERT(!opts.fill_zeros);
+		FRG_ASSERT(!opts.alt_conversion);
+
+		if(szmod == printf_size_mod::default_size) {
+			auto s = va_arg(vsp->args, const char *);
+			if(!s)
+				s = "(null)";
+
+			int length = string_view{s}.size();
+			if(opts.precision && *opts.precision < length)
+				length = *opts.precision;
+
+			if(opts.left_justify) {
+				for(int i = 0; i < length && s[i]; i++)
+					formatter.append(s[i]);
+				for(int i = length; i < opts.minimum_width; i++)
+					formatter.append(' ');
+			}else{
+				for(int i = length; i < opts.minimum_width; i++)
+					formatter.append(' ');
+				for(int i = 0; i < length && s[i]; i++)
+					formatter.append(s[i]);
+			}
+		}else{
+			FRG_ASSERT(szmod == printf_size_mod::long_size);
+			auto s = va_arg(vsp->args, const wchar_t *);
+			if(!s)
+				s = L"(null)";
+
+			int length = basic_string_view<wchar_t>{s}.size();
+			if(opts.precision && *opts.precision < length)
+				length = *opts.precision;
+
+			if(opts.left_justify) {
+				for(int i = 0; i < length && s[i]; i++)
+					formatter.append(s[i]);
+				for(int i = length; i < opts.minimum_width; i++)
+					formatter.append(' ');
+			}else{
+				for(int i = length; i < opts.minimum_width; i++)
+					formatter.append(' ');
+				for(int i = 0; i < length && s[i]; i++)
+					formatter.append(s[i]);
+			}
+		}
+	} break;
+	default:
+		FRG_ASSERT(!"Unexpected printf terminal");
+	}
+}
+
+template<typename F>
+void do_printf_ints(F &formatter, char t, format_options opts,
+		printf_size_mod szmod, va_struct *vsp, locale_options locale_opts = {}) {
+	switch(t) {
+	case 'd':
+	case 'i': {
+		FRG_ASSERT(!opts.alt_conversion);
+		long number;
+		if(szmod == printf_size_mod::long_size) {
+			number = va_arg(vsp->args, long);
+		}else if(szmod == printf_size_mod::longlong_size) {
+			number = va_arg(vsp->args, long long);
+		}else if(szmod == printf_size_mod::native_size) {
+			number = va_arg(vsp->args, intptr_t);
+		}else{
+			FRG_ASSERT(szmod == printf_size_mod::default_size);
+			number = va_arg(vsp->args, int);
+		}
+		if(opts.precision && *opts.precision == 0 && !number) {
+			// print nothing in this case
+		}else{
+			_fmt_basics::print_int(formatter, number, 10, opts.minimum_width,
+					opts.precision ? *opts.precision : 1, opts.fill_zeros ? '0' : ' ',
+					opts.left_justify, opts.group_thousands, locale_opts);
+		}
+	} break;
+	case 'o': {
+		auto print = [&] (auto number) {
+			if(opts.precision && *opts.precision == 0 && !number) {
+				// print nothing in this case
+			}else{
+				_fmt_basics::print_int(formatter, number, 8, opts.minimum_width,
+						opts.precision ? *opts.precision : 1, opts.fill_zeros ? '0' : ' ',
+						opts.left_justify, false, locale_opts);
+			}
+		};
+
+		if(opts.alt_conversion)
+			formatter.append('0');
+
+		if(szmod == printf_size_mod::long_size) {
+			print(va_arg(vsp->args, unsigned long));
+		}else{
+			FRG_ASSERT(szmod == printf_size_mod::default_size);
+			print(va_arg(vsp->args, unsigned int));
+		}
+	} break;
+	case 'x': {
+		FRG_ASSERT(!opts.alt_conversion);
+		auto print = [&] (auto number) {
+			if(opts.precision && *opts.precision == 0 && !number) {
+				// print nothing in this case
+			}else{
+				_fmt_basics::print_int(formatter, number, 16, opts.minimum_width,
+						opts.precision ? *opts.precision : 1, opts.fill_zeros ? '0' : ' ',
+						opts.left_justify, false, locale_opts);
+			}
+		};
+		if(szmod == printf_size_mod::long_size) {
+			print(va_arg(vsp->args, unsigned long));
+		}else{
+			FRG_ASSERT(szmod == printf_size_mod::default_size);
+			print(va_arg(vsp->args, unsigned int));
+		}
+	} break;
+	case 'X': {
+		FRG_ASSERT(!opts.alt_conversion);
+		auto print = [&] (auto number) {
+			if(opts.precision && *opts.precision == 0 && !number) {
+				// print nothing in this case
+			}else{
+				_fmt_basics::print_int(formatter, number, 16, opts.minimum_width,
+						opts.precision ? *opts.precision : 1, opts.fill_zeros ? '0' : ' ',
+						opts.left_justify, false, locale_opts);
+			}
+		};
+		if(szmod == printf_size_mod::long_size) {
+			print(va_arg(vsp->args, unsigned long));
+		}else{
+			print(va_arg(vsp->args, unsigned int));
+		}
+	} break;
+	case 'u': {
+		FRG_ASSERT(!opts.alt_conversion);
+		FRG_ASSERT(!opts.precision);
+		if(szmod == printf_size_mod::longlong_size) {
+			_fmt_basics::print_int(formatter, va_arg(vsp->args, unsigned long long),
+					10, opts.minimum_width,
+					1, opts.fill_zeros ? '0' : ' ',
+					opts.left_justify,
+					opts.group_thousands, locale_opts);
+		}else if(szmod == printf_size_mod::long_size) {
+			_fmt_basics::print_int(formatter, va_arg(vsp->args, unsigned long),
+					10, opts.minimum_width,
+					1, opts.fill_zeros ? '0' : ' ',
+					opts.left_justify,
+					opts.group_thousands, locale_opts);
+		}else if(szmod == printf_size_mod::native_size) {
+			_fmt_basics::print_int(formatter, va_arg(vsp->args, size_t),
+					10, opts.minimum_width,
+					1, opts.fill_zeros ? '0' : ' ',
+					opts.left_justify,
+					opts.group_thousands, locale_opts);
+		}else{
+			FRG_ASSERT(szmod == printf_size_mod::default_size);
+			_fmt_basics::print_int(formatter, va_arg(vsp->args, unsigned int),
+					10, opts.minimum_width,
+					1, opts.fill_zeros ? '0' : ' ',
+					opts.left_justify,
+					opts.group_thousands, locale_opts);
+		}
+	} break;
+	default:
+		FRG_ASSERT(!"Unexpected printf terminal");
+	}
+}
+
+template<typename F>
+void do_printf_floats(F &formatter, char t, format_options opts,
+		printf_size_mod szmod, va_struct *vsp, locale_options locale_opts = {}) {
+	switch(t) {
+	case 'f':
+	case 'F':
+		if (szmod == printf_size_mod::longdouble_size) {
+			_fmt_basics::print_float(formatter, va_arg(vsp->args, long double),
+					opts.minimum_width, opts.precision,
+					opts.fill_zeros ? '0' : ' ',
+					opts.group_thousands, locale_opts);
+		} else {
+			FRG_ASSERT(szmod == printf_size_mod::default_size);
+			_fmt_basics::print_float(formatter, va_arg(vsp->args, double),
+					opts.minimum_width, opts.precision,
+					opts.fill_zeros ? '0' : ' ',
+					opts.group_thousands, locale_opts);
+		}
+		break;
+	case 'g':
+	case 'G':
+	case 'e':
+	case 'E':
+		formatter.append("%f");
+		break;
+	default:
+		FRG_ASSERT(!"Unexpected printf terminal");
+	}
+}
+
+// ----------------------------------------------------------------------------
+
+struct char_fmt {
+	template<typename F>
+	friend void format_object(char_fmt self, format_options fo, F &formatter) {
+		(void)fo;
+		formatter.append(self.c_);
+	}
+
+	template<typename T>
+	char_fmt(const T &x)
+	: c_{static_cast<char>(x)} { }
+
+private:
+	const char c_;
+};
+
+template<typename T>
+struct hex_fmt {
+	template<typename F>
+	friend void format_object(hex_fmt self, format_options fo, F &formatter) {
+		format(*self._xp, fo.with_conversion(format_conversion::hex), formatter);
+	}
+
+	hex_fmt(const T &x)
+	: _xp{&x} { }
+
+private:
+	const T *_xp;
+};
+
+static inline char *strchr(const char *s, int c) {
+	while (*s) {
+		if (*s == c)
+			return const_cast<char *>(s);
+
+		s++;
+	}
+
+	return nullptr;
+}
+
+struct escape_fmt {
+	template<typename F>
+	friend void format_object(escape_fmt self, format_options fo, F &formatter) {
+		auto p = reinterpret_cast<const unsigned char *>(self._buffer);
+		for(size_t i = 0; i < self._size; i++) {
+			auto c = p[i];
+			if((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
+				formatter.append(c);
+			}else if(c >= '0' && c <= '9') {
+				formatter.append(c);
+			}else if(c == ' ') {
+				formatter.append(' ');
+			}else if(strchr("!#$%&()*+,-./:;<=>?@[]^_`{|}~", c)) {
+				formatter.append(c);
+			}else if(c == '\\') {
+				formatter.append("\\\\");
+			}else if(c == '\"') {
+				formatter.append("\\\"");
+			}else if(c == '\'') {
+				formatter.append("\\\'");
+			}else if(c == '\n') {
+				formatter.append("\\n");
+			}else if(c == '\t') {
+				formatter.append("\\t");
+			}else{
+				formatter.append("\\x{");
+				format((unsigned int)c, fo.with_conversion(format_conversion::hex), formatter);
+				formatter.append('}');
+			}
+		}
+	}
+
+	escape_fmt(const void *buffer, size_t size)
+	: _buffer{buffer}, _size{size} { }
+
+private:
+	const void *_buffer;
+	size_t _size;
+};
+
+// ----------------------------------------------------------------------------
+
+// ----------------------------------------------------------------------------
+// Formatting entry points.
+// ----------------------------------------------------------------------------
+
+// Internally calls format_object() with default options to format an object.
+// format_object() is an ADL customization point of this formatting library.
+template<typename T, typename F>
+void format(const T &object, F &formatter) {
+	format_object(object, format_options{}, formatter);
+}
+
+template<typename T, typename F>
+void format(const T &object, format_options fo, F &formatter) {
+	format_object(object, fo, formatter);
+}
+
+} // namespace frg
+
+#endif // FRG_FORMATTING_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/functional.hpp b/mlibc/subprojects/frigg/include/frg/functional.hpp
new file mode 100644
index 0000000..ceeb034
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/functional.hpp
@@ -0,0 +1,26 @@
+#pragma once
+
+#include <utility>
+
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<auto Ptr>
+struct bound_mem_fn;
+
+template<typename C, typename R, typename... Args, R (C:: *Ptr) (Args...)>
+struct bound_mem_fn<Ptr> {
+	bound_mem_fn(C *object)
+	: object_{object} { }
+
+	template<typename... X>
+	R operator() (X &&... args) {
+		return (object_->*Ptr)(std::forward<X>(args)...);
+	}
+
+private:
+	C *object_;
+};
+
+} // namespace frg
diff --git a/mlibc/subprojects/frigg/include/frg/hash.hpp b/mlibc/subprojects/frigg/include/frg/hash.hpp
new file mode 100644
index 0000000..7554cea
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/hash.hpp
@@ -0,0 +1,60 @@
+#ifndef FRG_HASH_HPP
+#define FRG_HASH_HPP
+
+#include <stdint.h>
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename T>
+class hash;
+
+template<>
+class hash<uint64_t> {
+public:
+	unsigned int operator() (uint64_t v) const {
+		static_assert(sizeof(unsigned int) == 4, "Expected sizeof(int) == 4");
+		return (unsigned int)(v ^ (v >> 32));
+	}
+};
+
+template<>
+class hash<int64_t> {
+public:
+	unsigned int operator() (int64_t v) const {
+		static_assert(sizeof(unsigned int) == 4, "Expected sizeof(int) == 4");
+		return (unsigned int)(v ^ (v >> 32));
+	}
+};
+
+template<>
+class hash<int> {
+public:
+	unsigned int operator() (int v) const {
+		return v;
+	}
+};
+
+template<typename T>
+class hash<T *> {
+public:
+	unsigned int operator() (T *p) const {
+		return reinterpret_cast<uintptr_t>(p);
+	}
+};
+
+class CStringHash {
+public:
+	unsigned int operator() (const char *str) const {
+		unsigned int value = 0;
+		while(*str != 0) {
+			value = (value << 8) | (value >> 24);
+			value += *str++;
+		}
+		return value;
+	}
+};
+
+} // namespace frg
+
+#endif // FRG_HASH_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/hash_map.hpp b/mlibc/subprojects/frigg/include/frg/hash_map.hpp
new file mode 100644
index 0000000..4bd5598
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/hash_map.hpp
@@ -0,0 +1,363 @@
+#ifndef FRG_HASHMAP_HPP
+#define FRG_HASHMAP_HPP
+
+#include <initializer_list>
+
+#include <frg/allocation.hpp>
+#include <frg/hash.hpp>
+#include <frg/macros.hpp>
+#include <frg/tuple.hpp>
+#include <frg/optional.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename Key, typename Value, typename Hash, typename Allocator>
+class hash_map {
+public:
+	typedef tuple<const Key, Value> entry_type;
+
+private:
+	struct chain {
+		entry_type entry;
+		chain *next;
+
+		chain(const Key &new_key, const Value &new_value)
+		: entry{new_key, new_value}, next{nullptr} { }
+
+		chain(const Key &new_key, Value &&new_value)
+		: entry{new_key, std::move(new_value)}, next{nullptr} { }
+	};
+
+public:
+	class iterator {
+	friend class hash_map;
+	public:
+		iterator &operator++ () {
+			FRG_ASSERT(item);
+			item = item->next;
+			if(item)
+				return *this;
+
+			FRG_ASSERT(bucket < map->_capacity);
+			while(true) {
+				bucket++;
+				if(bucket == map->_capacity)
+					break;
+				item = map->_table[bucket];
+				if(item)
+					break;
+			}
+
+			return *this;
+		}
+
+		bool operator== (const iterator &other) {
+			return (bucket == other.bucket) &&
+				(item == other.item);
+		}
+
+		entry_type &operator* () {
+			return item->entry;
+		}
+		entry_type *operator-> () {
+			return &item->entry;
+		}
+
+		operator bool () {
+			return item != nullptr;
+		}
+
+	private:
+		iterator(hash_map *map, size_t bucket, chain *item)
+		: map(map), item(item), bucket(bucket) { }
+
+		hash_map *map;
+		chain *item;
+		size_t bucket;
+	};
+
+	class const_iterator {
+	friend class hash_map;
+	public:
+		const_iterator &operator++ () {
+			FRG_ASSERT(item);
+			item = item->next;
+			if (item)
+				return *this;
+
+			FRG_ASSERT(bucket < map->_capacity);
+			while(true) {
+				bucket++;
+				if(bucket == map->_capacity)
+					break;
+				item = map->_table[bucket];
+				if(item)
+					break;
+			}
+
+			return *this;
+		}
+
+		bool operator== (const const_iterator &other) const {
+			return (bucket == other.bucket) &&
+				(item == other.item);
+		}
+
+		const entry_type &operator* () const {
+			return item->entry;
+		}
+		const entry_type *operator-> () const {
+			return &item->entry;
+		}
+
+		operator bool () const {
+			return item != nullptr;
+		}
+	private:
+		const_iterator(const hash_map *map, size_t bucket, const chain *item)
+		: map(map), item(item), bucket(bucket) { }
+
+		const hash_map *map;
+		const chain *item;
+		size_t bucket;
+	};
+
+	hash_map(const Hash &hasher, Allocator allocator = Allocator());
+	hash_map(const Hash &hasher, std::initializer_list<entry_type> init,
+			Allocator allocator = Allocator());
+	hash_map(const hash_map &) = delete;
+
+	~hash_map();
+
+	void insert(const Key &key, const Value &value);
+	void insert(const Key &key, Value &&value);
+	Value &operator[] (const Key &key);
+
+	bool empty() {
+		return !_size;
+	}
+
+	iterator end() {
+		return iterator(this, _capacity + 1, nullptr);
+	}
+
+	iterator find(const Key &key) {
+		if (!_size)
+			return end();
+
+		unsigned int bucket = ((unsigned int)_hasher(key) % _capacity);
+		for (chain *item = _table[bucket]; item != nullptr; item = item->next) {
+			if (item->entry.template get<0>() == key)
+				return iterator(*this, bucket, item);
+		}
+
+		return end();
+	}
+
+	iterator begin() {
+		if(!_size)
+			return iterator(this, _capacity, nullptr);
+
+		for(size_t bucket = 0; bucket < _capacity; bucket++) {
+			if(_table[bucket])
+				return iterator(this, bucket, _table[bucket]);
+		}
+		
+		FRG_ASSERT(!"hash_map corrupted");
+		__builtin_unreachable();
+	}
+
+	const_iterator end() const {
+		return const_iterator(this, _capacity, nullptr);
+	}
+
+	const_iterator find(const Key &key) const {
+		if (!_size)
+			return end();
+
+		unsigned int bucket = ((unsigned int)_hasher(key)) % _capacity;
+		for (const chain *item = _table[bucket]; item != nullptr; item = item->next) {
+			if (item->entry.template get<0>() == key)
+				return const_iterator(*this, bucket, item);
+		}
+
+		return end();
+	}
+	
+	template<typename KeyCompatible>
+	Value *get(const KeyCompatible &key);
+
+	optional<Value> remove(const Key &key);
+
+	size_t size() const {
+		return _size;
+	}
+
+private:
+	void rehash();
+	
+	Hash _hasher;
+	Allocator _allocator;
+	chain **_table;
+	size_t _capacity;
+	size_t _size;
+};
+
+template<typename Key, typename Value, typename Hash, typename Allocator>
+hash_map<Key, Value, Hash, Allocator>::hash_map(const Hash &hasher,
+		Allocator allocator)
+: _hasher(hasher), _allocator(std::move(allocator)), _table(nullptr), _capacity(0), _size(0) { }
+
+template<typename Key, typename Value, typename Hash, typename Allocator>
+hash_map<Key, Value, Hash, Allocator>::hash_map(const Hash &hasher,
+		std::initializer_list<entry_type> init, Allocator allocator)
+: _hasher(hasher), _allocator(std::move(allocator)), _table(nullptr), _capacity(0), _size(0) {
+	/* TODO: we know the size so we don't have to keep rehashing?? */
+	for (auto &entry : init) {
+		insert(entry.template get<0>(), entry.template get<1>());
+	}
+}
+
+template<typename Key, typename Value, typename Hash, typename Allocator>
+hash_map<Key, Value, Hash, Allocator>::~hash_map() {
+	for(size_t i = 0; i < _capacity; i++) {
+		chain *item = _table[i];
+		while(item != nullptr) {
+			chain *next = item->next;
+			frg::destruct(_allocator, item);
+			item = next;
+		}
+	}
+	_allocator.free(_table);
+}
+
+template<typename Key, typename Value, typename Hash, typename Allocator>
+void hash_map<Key, Value, Hash, Allocator>::insert(const Key &key, const Value &value) {
+	if(_size >= _capacity)
+		rehash();
+
+	FRG_ASSERT(_capacity > 0);
+	unsigned int bucket = ((unsigned int)_hasher(key)) % _capacity;
+	
+	auto item = frg::construct<chain>(_allocator, key, value);
+	item->next = _table[bucket];
+	_table[bucket] = item;
+	_size++;
+}
+template<typename Key, typename Value, typename Hash, typename Allocator>
+void hash_map<Key, Value, Hash, Allocator>::insert(const Key &key, Value &&value) {
+	if(_size >= _capacity)
+		rehash();
+
+	FRG_ASSERT(_capacity > 0);
+	unsigned int bucket = ((unsigned int)_hasher(key)) % _capacity;
+	
+	auto item = frg::construct<chain>(_allocator, key, std::move(value));
+	item->next = _table[bucket];
+	_table[bucket] = item;
+	_size++;
+}
+
+template<typename Key, typename Value, typename Hash, typename Allocator>
+Value &hash_map<Key, Value, Hash, Allocator>::operator[](const Key &key) {
+	/* empty map case */
+	if (_size == 0) {
+		rehash();
+		unsigned int bucket = ((unsigned int)_hasher(key)) % _capacity;
+		auto item = frg::construct<chain>(_allocator, key, Value{});
+		item->next = _table[bucket];
+		_table[bucket] = item;
+		_size++;
+	}
+
+	unsigned int bucket = ((unsigned int)_hasher(key)) % _capacity;
+	for (chain *item = _table[bucket]; item != nullptr; item = item->next) {
+		if (item->entry.template get<0>() == key)
+			return item->entry.template get<1>();
+	}
+
+	if (_size >= _capacity)
+		rehash();
+
+	auto item = frg::construct<chain>(_allocator, key, Value{});
+	item->next = _table[bucket];
+	_table[bucket] = item;
+	_size++;
+	return item->entry.template get<1>();
+}
+
+template<typename Key, typename Value, typename Hash, typename Allocator>
+template<typename KeyCompatible>
+Value *hash_map<Key, Value, Hash, Allocator>::get(const KeyCompatible &key) {
+	if(_size == 0)
+		return nullptr;
+
+	unsigned int bucket = ((unsigned int)_hasher(key)) % _capacity;
+
+	for(chain *item = _table[bucket]; item != nullptr; item = item->next) {
+		if(item->entry.template get<0>() == key)
+			return &item->entry.template get<1>();
+	}
+
+	return nullptr;
+}
+
+template<typename Key, typename Value, typename Hash, typename Allocator>
+optional<Value> hash_map<Key, Value, Hash, Allocator>::remove(const Key &key) {
+	if(_size == 0)
+		return null_opt;
+
+	unsigned int bucket = ((unsigned int)_hasher(key)) % _capacity;
+	
+	chain *previous = nullptr;
+	for(chain *item = _table[bucket]; item != nullptr; item = item->next) {
+		if(item->entry.template get<0>() == key) {
+			Value value = std::move(item->entry.template get<1>());
+			
+			if(previous == nullptr) {
+				_table[bucket] = item->next;
+			}else{
+				previous->next = item->next;
+			}
+			frg::destruct(_allocator, item);
+			_size--;
+
+			return value;
+		}
+
+		previous = item;
+	}
+
+	return null_opt;
+}
+
+template<typename Key, typename Value, typename Hash, typename Allocator>
+void hash_map<Key, Value, Hash, Allocator>::rehash() {
+	size_t new_capacity = 2 * _size;
+	if(new_capacity < 10)
+		new_capacity = 10;
+
+	chain **new_table = (chain **)_allocator.allocate(sizeof(chain *) * new_capacity);
+	for(size_t i = 0; i < new_capacity; i++)
+		new_table[i] = nullptr;
+	
+	for(size_t i = 0; i < _capacity; i++) {
+		chain *item = _table[i];
+		while(item != nullptr) {
+			auto bucket = ((unsigned int)_hasher(item->entry.template get<0>())) % new_capacity;
+
+			chain *next = item->next;
+			item->next = new_table[bucket];
+			new_table[bucket] = item;
+			item = next;
+		}
+	}
+
+	_allocator.free(_table);
+	_table = new_table;
+	_capacity = new_capacity;
+}
+
+} // namespace frg
+
+#endif // FRG_HASHMAP_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/interval_tree.hpp b/mlibc/subprojects/frigg/include/frg/interval_tree.hpp
new file mode 100644
index 0000000..a06414a
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/interval_tree.hpp
@@ -0,0 +1,138 @@
+#ifndef FRG_INTERVAL_TREE_HPP
+#define FRG_INTERVAL_TREE_HPP
+
+#include <frg/macros.hpp>
+#include <frg/rbtree.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename P>
+struct interval_hook {
+	P subtree_max;
+};
+
+// Reference: Cormen et al., 'Introduction to Algorithms', 3rd edition.
+template<
+	typename T,
+	typename P,
+	P T:: *L,
+	P T:: *U,
+	rbtree_hook T ::*R,
+	interval_hook<P> T:: *H
+>
+struct interval_tree {
+	static P lower(const T *node) {
+		return node->*L;
+	}
+	static P upper(const T *node) {
+		return node->*U;
+	}
+
+	static interval_hook<P> *h(T *node) {
+		return &(node->*H);
+	}
+
+	struct lb_less {
+		bool operator() (const T &x, const T &y) const {
+			return lower(&x) < lower(&y);
+		}
+	};
+
+	struct aggregator;
+
+	using binary_tree = rbtree<
+		T,
+		R,
+		lb_less,
+		aggregator
+	>;
+
+	struct aggregator {
+		static bool aggregate(T *node) {
+			auto left = binary_tree::get_left(node);
+			auto right = binary_tree::get_right(node);
+
+			P new_max = upper(node);
+			if (left && new_max < h(left)->subtree_max)
+				new_max = h(left)->subtree_max;
+			if (right && new_max < h(right)->subtree_max)
+				new_max = h(right)->subtree_max;
+
+			if(new_max == h(node)->subtree_max)
+				return false;
+			h(node)->subtree_max = new_max;
+			return true;
+		}
+
+		static bool check_invariant(binary_tree &tree, T *node) {
+			return true;
+		}
+	};
+
+	void insert(T *node) {
+		FRG_ASSERT(lower(node) <= upper(node));
+		h(node)->subtree_max = upper(node);
+		_rbtree.insert(node);
+	}
+
+	void remove(T *node) {
+		_rbtree.remove(node);
+	}
+
+	template<typename F>
+	void for_overlaps(F fn, P lb, P ub) {
+		auto root = _rbtree.get_root();
+		if(!root)
+			return;
+		_for_overlaps_in_subtree(fn, lb, ub, root);
+	}
+
+	template<typename F>
+	void for_overlaps(F fn, P singleton) {
+		for_overlaps(std::forward<F>(fn), singleton, singleton);
+	}
+
+	template<typename F>
+	bool _for_overlaps_in_subtree(F &fn, P lb, P ub, T *node) {
+		FRG_ASSERT(node);
+
+		auto left = binary_tree::get_left(node);
+		auto right = binary_tree::get_right(node);
+
+		if((lower(node) <= lb && lb <= upper(node))
+				|| (lb <= lower(node) && lower(node) <= ub)) {
+			fn(node);
+
+			if(left)
+				_for_overlaps_in_subtree(fn, lb, ub, left);
+			if(right)
+				_for_overlaps_in_subtree(fn, lb, ub, right);
+			return true;
+		}
+
+		if(left && lb <= h(left)->subtree_max) {
+			// If the preceeding if guarantees the following property:
+			// If an overlapping interval exists, such an interval is in the left subtree
+			// (but not *all* overlapping intervals need to be in the left subtree).
+			// Thus, our strategy is to check the left subtree first and *only* if an interval
+			// exists in the left subtree, we *also* check the right subtree.
+			if(_for_overlaps_in_subtree(fn, lb, ub, left)) {
+				if(right)
+					_for_overlaps_in_subtree(fn, lb, ub, right);
+				return true;
+			}
+		}else if(right) {
+			if(_for_overlaps_in_subtree(fn, lb, ub, right))
+				return true;
+		}
+
+		return false;
+	}
+
+private:
+	binary_tree _rbtree;
+};
+
+} // namespace frg
+
+#endif // FRG_INTERVAL_TREE_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/intrusive.hpp b/mlibc/subprojects/frigg/include/frg/intrusive.hpp
new file mode 100644
index 0000000..ec51612
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/intrusive.hpp
@@ -0,0 +1,27 @@
+#ifndef FRG_INTRUSIVE_HPP
+#define FRG_INTRUSIVE_HPP
+
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename T, typename OwnerPointer, typename BorrowPointer>
+struct intrusive_traits;
+
+template<typename T>
+struct intrusive_traits<T, T *, T *> {
+	static T *decay(T *owner) {
+		return owner;
+	}
+};
+
+template<typename T, typename H, H T::*Member>
+struct locate_member {
+	H &operator() (T &x) {
+		return x.*Member;
+	}
+};
+
+} // namespace frg
+
+#endif // FRG_INTRUSIVE_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/list.hpp b/mlibc/subprojects/frigg/include/frg/list.hpp
new file mode 100644
index 0000000..f7e0813
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/list.hpp
@@ -0,0 +1,293 @@
+#pragma once
+
+#include <type_traits>
+#include <utility>
+#include <frg/allocation.hpp>
+#include <frg/intrusive.hpp>
+#include <frg/macros.hpp>
+#include <frg/utility.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+namespace _list {
+
+template<typename OwnerPointer, typename BorrowPointer>
+struct intrusive_list_hook {
+	using owner_pointer = OwnerPointer;
+	using borrow_pointer = BorrowPointer;
+
+	constexpr intrusive_list_hook()
+	: next{nullptr}, previous{nullptr}, in_list{false} { }
+
+	owner_pointer next;
+	borrow_pointer previous;
+	bool in_list;
+};
+
+struct locate_tag { };
+
+template<typename T, typename Locate>
+struct intrusive_list : private composition<locate_tag, Locate> {
+private:
+	using hook = std::remove_reference_t<std::result_of_t<Locate(T &)>>;
+	using owner_pointer = typename hook::owner_pointer;
+	using borrow_pointer = typename hook::borrow_pointer;
+	using traits = intrusive_traits<T, owner_pointer, borrow_pointer>;
+
+	hook &h(borrow_pointer ptr) {
+		return get<locate_tag>(this)(*ptr);
+	}
+
+public:
+	struct iterator : private composition<locate_tag, Locate> {
+	friend struct intrusive_list;
+	private:
+		hook &h(borrow_pointer ptr) {
+			return get<locate_tag>(this)(*ptr);
+		}
+
+	public:
+		iterator(borrow_pointer current)
+		: _current(current) { }
+
+		borrow_pointer operator* () const {
+			return _current;
+		}
+
+		bool operator== (const iterator &other) const {
+			return _current == other._current;
+		}
+		bool operator!= (const iterator &other) const {
+			return !(*this == other);
+		}
+
+		iterator &operator++ () {
+			_current = h(_current).next;
+			return *this;
+		}
+		iterator operator++ (int) {
+			auto copy = *this;
+			++(*this);
+			return copy;
+		}
+
+	private:
+		borrow_pointer _current;
+	};
+
+	iterator iterator_to(borrow_pointer ptr) {
+		FRG_ASSERT(h(ptr).in_list);
+		return iterator{ptr};
+	}
+
+	constexpr intrusive_list()
+	: _front{nullptr}, _back{nullptr} { }
+
+	iterator push_front(owner_pointer element) {
+		FRG_ASSERT(element);
+		borrow_pointer borrow = traits::decay(element);
+		FRG_ASSERT(!h(borrow).in_list);
+		FRG_ASSERT(!h(borrow).next);
+		FRG_ASSERT(!h(borrow).previous);
+		if(!_front) {
+			_back = borrow;
+		}else{
+			h(borrow).next = std::move(_front);
+			h(_front).previous = borrow;
+		}
+		_front = std::move(element);
+		h(borrow).in_list = true;
+		return iterator{borrow};
+	}
+
+	iterator push_back(owner_pointer element) {
+		FRG_ASSERT(element);
+		borrow_pointer borrow = traits::decay(element);
+		FRG_ASSERT(!h(borrow).in_list);
+		FRG_ASSERT(!h(borrow).next);
+		FRG_ASSERT(!h(borrow).previous);
+		if(!_back) {
+			_front = std::move(element);
+		}else{
+			h(borrow).previous = _back;
+			h(_back).next = std::move(element);
+		}
+		_back = borrow;
+		h(borrow).in_list = true;
+		return iterator{borrow};
+	}
+
+	iterator insert(iterator before, owner_pointer element) {
+		if(!before._current) {
+			return push_back(element);
+		}else if(before._current == _front) {
+			return push_front(element);
+		}
+
+		FRG_ASSERT(element);
+		borrow_pointer borrow = traits::decay(element);
+		FRG_ASSERT(!h(borrow).in_list);
+		FRG_ASSERT(!h(borrow).next);
+		FRG_ASSERT(!h(borrow).previous);
+		borrow_pointer previous = h(before._current).previous;
+		owner_pointer next = std::move(h(previous).next);
+
+		h(previous).next = std::move(element);
+		h(traits::decay(next)).previous = borrow;
+		h(borrow).previous = previous;
+		h(borrow).next = std::move(next);
+		h(borrow).in_list = true;
+		return iterator{borrow};
+	}
+
+	bool empty() {
+		return !_front;
+	}
+
+	borrow_pointer front() {
+		return _front;
+	}
+	borrow_pointer back() {
+		return _back;
+	}
+
+	owner_pointer pop_front() {
+		FRG_ASSERT(h(_front).in_list);
+		return erase(iterator{_front});
+	}
+	owner_pointer pop_back() {
+		FRG_ASSERT(h(_back).in_list);
+		return erase(iterator{_back});
+	}
+
+	owner_pointer erase(iterator it) {
+		FRG_ASSERT(it._current);
+		FRG_ASSERT(h(it._current).in_list);
+		owner_pointer next = std::move(h(it._current).next);
+		borrow_pointer previous = h(it._current).previous;
+
+		if(!next) {
+			FRG_ASSERT(_back == it._current);
+			_back = previous;
+		}else{
+			FRG_ASSERT(h(traits::decay(next)).previous == it._current);
+			h(traits::decay(next)).previous = previous;
+		}
+
+		owner_pointer erased;
+		if(!previous) {
+			FRG_ASSERT(traits::decay(_front) == it._current);
+			erased = std::move(_front);
+			_front = std::move(next);
+		}else{
+			FRG_ASSERT(traits::decay(h(previous).next) == it._current);
+			erased = std::move(h(previous).next);
+			h(previous).next = std::move(next);
+		}
+
+		FRG_ASSERT(traits::decay(erased) == it._current);
+		h(it._current).next = nullptr;
+		h(it._current).previous = nullptr;
+		h(it._current).in_list = false;
+
+		return erased;
+	}
+
+	void clear() {
+		while(!empty())
+			pop_front();
+	}
+
+	void splice(iterator it, intrusive_list &other) {
+		FRG_ASSERT(!it._current);
+		
+		if(!other._front)
+			return;
+
+		borrow_pointer borrow = traits::decay(other._front);
+		FRG_ASSERT(h(borrow).in_list);
+		FRG_ASSERT(!h(borrow).previous);
+		if(!_back) {
+			_front = std::move(other._front);
+		}else{
+			h(borrow).previous = _back;
+			h(_back).next = std::move(other._front);
+		}
+		_back = other._back;
+
+		other._front = nullptr;
+		other._back = nullptr;
+	}
+
+	iterator begin() {
+		return iterator{traits::decay(_front)};
+	}
+	iterator end() {
+		return iterator{nullptr};
+	}
+
+private:
+	owner_pointer _front;
+	borrow_pointer _back;
+};
+
+} // namespace _list
+
+using _list::intrusive_list_hook;
+using _list::intrusive_list;
+
+template<typename T>
+using default_list_hook = intrusive_list_hook<
+	std::add_pointer_t<T>,
+	std::add_pointer_t<T>
+>;
+
+template<typename T, typename Allocator>
+struct list {
+private:
+	struct item {
+		template<typename... Args>
+		item(Args &&... args)
+		: object(std::forward<Args>(args)...) { }
+
+		T object;
+		frg::default_list_hook<item> hook;
+	};
+
+public:
+	list(Allocator allocator = {})
+	: allocator_{std::move(allocator)} { }
+
+	template<typename... Args>
+	void emplace_back(Args &&... args) {
+		auto e = frg::construct<item>(allocator_, std::forward<Args>(args)...);
+		items_.push_back(e);
+	}
+
+	bool empty() {
+		return items_.empty();
+	}
+
+	T &front() {
+		return items_.front()->object;
+	}
+
+	void pop_front() {
+		auto e = items_.pop_front();
+		frg::destruct(allocator_, e);
+	}
+
+private:
+	Allocator allocator_;
+
+	frg::intrusive_list<
+		item,
+		frg::locate_member<
+			item,
+			frg::default_list_hook<item>,
+			&item::hook
+		>
+	> items_;
+};
+
+} // namespace frg
diff --git a/mlibc/subprojects/frigg/include/frg/logging.hpp b/mlibc/subprojects/frigg/include/frg/logging.hpp
new file mode 100644
index 0000000..568e8e1
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/logging.hpp
@@ -0,0 +1,88 @@
+#ifndef FRG_LOGGING_HPP
+#define FRG_LOGGING_HPP
+
+#include <utility>
+#include <frg/formatting.hpp>
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+struct endlog_t { };
+//TODO: Make this inline.
+static constexpr endlog_t endlog;
+
+template<typename Sink, size_t Limit = 128>
+struct stack_buffer_logger {
+	struct item {
+		item(stack_buffer_logger *logger)
+		: _logger{logger}, _off{0}, _emitted{false} { }
+
+		item(const item &) = delete;
+
+		item &operator= (const item &) = delete;
+
+		~item() {
+			// TODO: Warn here.
+		}
+
+		template<typename T>
+		item &operator<< (T object) {
+			format(object, *this);
+			return *this;
+		}
+
+		item &operator<< (endlog_t) {
+			FRG_ASSERT(_off < Limit);
+			_buffer[_off] = 0;
+			_logger->_emit(_buffer);
+			return *this;
+		}
+
+		void append(char s) {
+			FRG_ASSERT(_off < Limit);
+			if(_off + 1 == Limit) {
+				_buffer[_off] = 0;
+				_logger->_emit(_buffer);
+				_off = 0;
+			}
+			_buffer[_off++] = s;
+		}
+
+		void append(const char *str) {
+			while(*str) {
+				FRG_ASSERT(_off < Limit);
+				if(_off + 1 == Limit) {
+					_buffer[_off] = 0;
+					_logger->_emit(_buffer);
+					_off = 0;
+				}
+				_buffer[_off++] = *str++;
+			}
+		}
+
+	private:
+		stack_buffer_logger *_logger;
+		char _buffer[Limit];
+		size_t _off;
+		bool _emitted;
+	};
+
+	// constexpr so that this can be initialized statically.
+	constexpr stack_buffer_logger(Sink sink = Sink{})
+	: _sink{std::move(sink)} { }
+
+	item operator() () {
+		return item{this};
+	}
+
+private:
+	void _emit(const char *message) {
+		_sink(message);
+	}
+
+	Sink _sink;
+};
+
+} // namespace frg
+
+#endif // FRG_LOGGING_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/macros.hpp b/mlibc/subprojects/frigg/include/frg/macros.hpp
new file mode 100644
index 0000000..9a45bf0
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/macros.hpp
@@ -0,0 +1,37 @@
+#ifndef FRG_MACROS_HPP
+#define FRG_MACROS_HPP
+
+#define FRG_STRINGIFY(x) #x
+#define FRG_EVALSTRINGIFY(x) FRG_STRINGIFY(x)
+
+#define FRG_INTF(x) frg_ ## x
+
+extern "C" {
+	[[gnu::weak]] void FRG_INTF(log)(const char *cstring);
+	[[gnu::weak]] void FRG_INTF(panic)(const char *cstring);
+}
+
+// TODO: Switch visibility depending on compilation flags.
+#define FRG_VISIBILITY
+
+// TODO: Actually provide assertions.
+#define FRG_ASSERT(x) do { \
+	if(!(x)) { \
+		if(!FRG_INTF(panic)) \
+			__builtin_trap(); \
+		FRG_INTF(panic)(__FILE__ ":" FRG_EVALSTRINGIFY(__LINE__) \
+				": Assertion '" #x "' failed!"); \
+		__builtin_trap(); \
+	}\
+} while(0)
+
+#define FRG_DEBUG_ASSERT(x) do { \
+	if(!(x)) { \
+		if(!FRG_INTF(log)) \
+			break; \
+		FRG_INTF(log)(__FILE__ ":" FRG_EVALSTRINGIFY(__LINE__) \
+				": Assertion '" #x "' failed!"); \
+	}\
+} while(0)
+
+#endif // FRG_MACROS_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/manual_box.hpp b/mlibc/subprojects/frigg/include/frg/manual_box.hpp
new file mode 100644
index 0000000..873243d
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/manual_box.hpp
@@ -0,0 +1,65 @@
+#ifndef FRG_MANUAL_BOX_HPP
+#define FRG_MANUAL_BOX_HPP
+
+#include <new>
+#include <utility>
+
+#include <frg/eternal.hpp>
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename T>
+class manual_box {
+public:
+	constexpr manual_box()
+	: _initialized{false} { }
+
+	template<typename... Args>
+	void initialize(Args &&... args) {
+		FRG_ASSERT(!_initialized);
+		new(&_storage) T(std::forward<Args>(args)...);
+		_initialized = true;
+	}
+
+	template<typename F, typename... Args>
+	void construct_with(F f) {
+		FRG_ASSERT(!_initialized);
+		new(&_storage) T{f()};
+		_initialized = true;
+	}
+
+	void destruct() {
+		FRG_ASSERT(_initialized);
+		get()->T::~T();
+		_initialized = false;
+	}
+
+	T *get() {
+		FRG_ASSERT(_initialized);
+		return std::launder(reinterpret_cast<T *>(&_storage));
+	}
+
+	bool valid() {
+		return _initialized;
+	}
+
+	operator bool () {
+		return _initialized;
+	}
+
+	T *operator-> () {
+		return get();
+	}
+	T &operator* () {
+		return *get();
+	}
+
+private:
+	aligned_storage<sizeof(T), alignof(T)> _storage;
+	bool _initialized;
+};
+
+} // namespace frigg
+
+#endif // FRG_MANUAL_BOX_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/mutex.hpp b/mlibc/subprojects/frigg/include/frg/mutex.hpp
new file mode 100644
index 0000000..90274be
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/mutex.hpp
@@ -0,0 +1,87 @@
+#ifndef FRG_MUTEX_HPP
+#define FRG_MUTEX_HPP
+
+#include <utility>
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+struct dont_lock_t { };
+
+constexpr dont_lock_t dont_lock = dont_lock_t();
+
+template<typename Mutex>
+class unique_lock {
+public:
+	friend void swap(unique_lock &u, unique_lock &v) {
+		using std::swap;
+		swap(u._mutex, v._mutex);
+		swap(u._is_locked, v._is_locked);
+	}
+
+	unique_lock()
+	: _mutex{nullptr}, _is_locked{false} { }
+
+	unique_lock(dont_lock_t, Mutex &mutex)
+	: _mutex{&mutex}, _is_locked{false} { }
+
+	unique_lock(Mutex &mutex)
+	: _mutex{&mutex}, _is_locked{false} {
+		lock();
+	}
+
+	unique_lock(const unique_lock &other) = delete;
+	
+	unique_lock(unique_lock &&other)
+	: unique_lock() {
+		swap(*this, other);
+	}
+
+	~unique_lock() {
+		if(_is_locked)
+			unlock();
+	}
+
+	unique_lock &operator= (unique_lock other) {
+		swap(*this, other);
+		return *this;
+	}
+
+	void lock() {
+		FRG_ASSERT(!_is_locked);
+		_mutex->lock();
+		_is_locked = true;
+	}
+
+	void unlock() {
+		FRG_ASSERT(_is_locked);
+		_mutex->unlock();
+		_is_locked = false;
+	}
+
+	bool is_locked() {
+		return _is_locked;
+	}
+
+	bool protects(Mutex *mutex) {
+		return _is_locked && mutex == _mutex;
+	}
+
+private:
+	Mutex *_mutex;
+	bool _is_locked;
+};
+
+template<typename Mutex>
+unique_lock<Mutex> guard(Mutex *mutex) {
+	return unique_lock<Mutex>(*mutex);
+}
+
+template<typename Mutex>
+unique_lock<Mutex> guard(dont_lock_t, Mutex *mutex) {
+	return unique_lock<Mutex>(dont_lock, *mutex);
+}
+
+} // namespace frg
+
+#endif // FRG_MUTEX_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/optional.hpp b/mlibc/subprojects/frigg/include/frg/optional.hpp
new file mode 100644
index 0000000..72d9d73
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/optional.hpp
@@ -0,0 +1,207 @@
+#ifndef FRG_OPTIONAL_HPP
+#define FRG_OPTIONAL_HPP
+
+#include <new>
+#include <utility>
+
+#include <frg/eternal.hpp>
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+struct null_opt_type { };
+static constexpr null_opt_type null_opt;
+
+template<typename T>
+class optional {
+public:
+	using value_type = T;
+
+	optional()
+	: _non_null{false} { }
+	
+	optional(null_opt_type)
+	: _non_null{false} { }
+
+	optional(const T &object)
+	: _non_null{true} {
+		new (_stor.buffer) T(object);
+	}
+
+	optional(T &&object)
+	: _non_null{true} {
+		new (_stor.buffer) T(std::move(object));
+	}
+
+	template<typename U = value_type, typename =
+		std::enable_if_t<std::is_constructible_v<T, U&&>>>
+	constexpr optional(U &&value)
+	: _non_null{true} {
+		new (_stor.buffer) T(std::forward<U>(value));
+	}
+
+	optional(const optional &other)
+	: _non_null{other._non_null} {
+		if(_non_null)
+			new (_stor.buffer) T(*other._object());
+	}
+
+	optional(optional &&other)
+	: _non_null{other._non_null} {
+		if(_non_null)
+			new (_stor.buffer) T(std::move(*other._object()));
+	}
+
+	~optional() {
+		if(_non_null)
+			_reset();
+	}
+
+	optional &operator= (const optional &other) {
+		if (other._non_null) {
+			if (_non_null) {
+				*_object() = *other._object();
+			} else {
+				new (_stor.buffer) T(*other._object());
+				_non_null = true;
+			}
+		} else {
+			if(_non_null)
+				_reset();
+		}
+		return *this;
+	}
+
+	optional &operator= (optional &&other) {
+		if (other._non_null) {
+			if (_non_null) {
+				*_object() = std::move(*other._object());
+			} else {
+				new (_stor.buffer) T(std::move(*other._object()));
+				_non_null = true;
+			}
+		} else {
+			if(_non_null)
+				_reset();
+		}
+		return *this;
+	}
+
+	// Exactly the same as above but for more general types.
+	template<class U>
+	optional &operator= (const optional<U> &other) {
+		if (other._non_null) {
+			if (_non_null) {
+				*_object() = *other._object();
+			} else {
+				new (_stor.buffer) T(*other._object());
+				_non_null = true;
+			}
+		} else {
+			if(_non_null)
+				_reset();
+		}
+		return *this;
+	}
+
+	// Exactly the same as above but for more general types.
+	template<class U>
+	optional &operator= (optional<U> &&other) {
+		if (other._non_null) {
+			if (_non_null) {
+				*_object() = std::move(*other._object());
+			} else {
+				new (_stor.buffer) T(std::move(*other._object()));
+				_non_null = true;
+			}
+		} else {
+			if(_non_null)
+				_reset();
+		}
+		return *this;
+	}
+
+
+	constexpr operator bool() const {
+		return _non_null;
+	}
+	constexpr operator bool() {
+		return _non_null;
+	}
+
+	constexpr bool has_value() const {
+		return _non_null;
+	}
+
+	constexpr const T &operator* () const {
+		FRG_ASSERT(_non_null);
+		return *_object();
+	}
+	constexpr T &operator* () {
+		FRG_ASSERT(_non_null);
+		return *_object();
+	}
+	T *operator-> () {
+		FRG_ASSERT(_non_null);
+		return _object();
+	}
+	T &value() {
+		FRG_ASSERT(_non_null);
+		return *_object();
+	}
+
+	template <typename ...Args>
+	void emplace(Args &&...args) {
+		if(_non_null)
+			_reset();
+		new (_stor.buffer) T(std::forward<Args>(args)...);
+		_non_null = true;
+	}
+
+private:
+	const T *_object() const {
+		return std::launder(reinterpret_cast<const T *>(_stor.buffer));
+	}
+	T *_object() {
+		return std::launder(reinterpret_cast<T *>(_stor.buffer));
+	}
+
+	void _reset() {
+		_object()->~T();
+		_non_null = false;
+	}
+
+	aligned_storage<sizeof(T), alignof(T)> _stor;
+	bool _non_null;
+};
+
+template<class T, class U>
+constexpr bool operator==(const optional<T> &opt, const U &value) {
+	return opt ? (*opt == value) : false;
+}
+template<class T, class U>
+constexpr bool operator==(const U &value, const optional<T> &opt) {
+	return opt ? (value == *opt) : false;
+}
+
+template<class T, class U>
+constexpr bool operator!=(const optional<T> &opt, const U &value) {
+	return opt ? (*opt != value) : true;
+}
+template<class T, class U>
+constexpr bool operator!=(const U &value, const optional<T> &opt) {
+	return opt ? (value != *opt) : true;
+}
+
+template<class T, class U>
+constexpr bool operator<(const optional<T> &opt, const U &value) {
+	return opt ? (*opt < value) : true;
+}
+template<class T, class U>
+constexpr bool operator<(const T &value, const optional<U> &opt) {
+	return opt ? (value < *opt) : false;
+}
+
+} // namespace frg
+
+#endif // FRG_OPTIONAL_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/pairing_heap.hpp b/mlibc/subprojects/frigg/include/frg/pairing_heap.hpp
new file mode 100644
index 0000000..3bcbed2
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/pairing_heap.hpp
@@ -0,0 +1,240 @@
+#ifndef FRG_PAIRING_HEAP_HPP
+#define FRG_PAIRING_HEAP_HPP
+
+#include <frg/macros.hpp>
+#include <frg/utility.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+namespace _pairing {
+
+// Each element of a pairing heap consists of three pointers:
+// * child: Points to the first child.
+// * backlink: Points to the previous sibling or (if the element is the first
+//   child of its parent) to the element's parent.
+// * sibling: Points to the next sibling.
+// The backlink is required to support deletion of arbitrary elements.
+template<typename T>
+struct pairing_heap_hook {
+	pairing_heap_hook()
+	: child{nullptr}, backlink{nullptr}, sibling{nullptr} { }
+
+	pairing_heap_hook(const pairing_heap_hook &) = delete;
+
+	~pairing_heap_hook() {
+		FRG_ASSERT(!child);
+		FRG_ASSERT(!backlink && !sibling);
+	}
+
+	pairing_heap_hook &operator= (const pairing_heap_hook &) = delete;
+
+	T *child;
+	T *backlink;
+	T *sibling;
+};
+
+// Tags for frg::composition.
+struct locate { };
+struct compare { };
+
+template<typename T, typename Locate, typename Compare>
+struct pairing_heap : private composition<locate, Locate>,
+		private composition<compare, Compare> {
+private:
+	// ------------------------------------------------------------------------
+	// Algorithm details.
+	// ------------------------------------------------------------------------
+
+	pairing_heap_hook<T> &h(T *p) {
+		return get<locate>(this)(*p);
+	}
+
+	// Merges two heaps.
+	T *_merge(T *a, T *b) {
+		FRG_ASSERT(!h(a).backlink && !h(a).sibling);
+		FRG_ASSERT(!h(b).backlink && !h(b).sibling);
+
+		// Merge the smaller element into the greater one.
+		if(get<compare>(this)(a, b)) {
+			auto sibling = h(b).child;
+			if(sibling) {
+				FRG_ASSERT(h(sibling).backlink == b);
+				h(sibling).backlink = a;
+			}
+			h(a).sibling = sibling;
+			h(a).backlink = b;
+			h(b).child = a;
+			return b;
+		}else{
+			auto sibling = h(a).child;
+			if(sibling) {
+				FRG_ASSERT(h(sibling).backlink == a);
+				h(sibling).backlink = b;
+			}
+			h(b).sibling = sibling;
+			h(b).backlink = a;
+			h(a).child = b;
+			return a;
+		}
+	}
+
+	// Takes a doubly linked list of heaps (via the backlink/sibling pointers)
+	// and merges them all into a single heap.
+	T *_collapse(T *head) {
+		FRG_ASSERT(head);
+
+		// First we build a singly linked list of merged pairs.
+		// We store this list in the backlink pointer.
+		T *paired = nullptr;
+
+		T *element = head;
+		while(element && h(element).sibling) {
+			auto partner = h(element).sibling;
+			auto next = h(partner).sibling;
+
+			// Detach both elements from the heap.
+			h(element).backlink = nullptr;
+			h(element).sibling = nullptr;
+
+			FRG_ASSERT(h(partner).backlink == element);
+			h(partner).backlink = nullptr;
+			h(partner).sibling = nullptr;
+
+			// Actually merge the pairs and build the linked list.
+			auto merged = _merge(element, partner);
+			FRG_ASSERT(!h(merged).backlink);
+			h(merged).backlink = paired;
+			paired = merged;
+
+			element = next;
+		}
+
+		// Now merge all elements of the linked list.
+		// This should be done in the reserve order of inserting them.
+		T *joined;
+		if(element) {
+			// There is a single element remaining that is not part
+			// of the linked list.
+			h(element).backlink = nullptr;
+			joined = element;
+		}else{
+			auto predecessor = h(paired).backlink;
+
+			// There is no element remaining.
+			// Take the first element from the linked list instead.
+			h(paired).backlink = nullptr;
+			FRG_ASSERT(!h(paired).sibling);
+			joined = paired;
+
+			paired = predecessor;
+		}
+
+		while(paired) {
+			auto predecessor = h(paired).backlink;
+
+			// Remove an element of the linked list and merge it with all others.
+			h(paired).backlink = nullptr;
+			FRG_ASSERT(!h(paired).sibling);
+			joined = _merge(joined, paired);
+
+			paired = predecessor;
+		}
+
+		return joined;
+	}
+
+	// ------------------------------------------------------------------------
+	// Interface functions.
+	// ------------------------------------------------------------------------
+public:
+	pairing_heap()
+	: _root{nullptr} { }
+
+	pairing_heap(const pairing_heap &) = delete;
+	
+	~pairing_heap() {
+		FRG_ASSERT(!_root);
+	}
+
+	pairing_heap &operator= (const pairing_heap &) = delete;
+
+	bool empty() {
+		return _root == nullptr;
+	}
+
+	void push(T *element) {
+		FRG_ASSERT(!h(element).child);
+		FRG_ASSERT(!h(element).backlink && !h(element).sibling);
+		
+		if(_root) {
+			_root = _merge(_root, element);
+		}else{
+			_root = element;
+		}
+	}
+
+	void pop() {
+		FRG_ASSERT(_root);
+		auto child = h(_root).child;
+		
+		// Remove the root from the heap.
+		h(_root).child = nullptr;
+		FRG_ASSERT(!h(_root).backlink && !h(_root).sibling);
+
+		// Fix up the remaining heap.
+		if(child) {
+			FRG_ASSERT(h(child).backlink == _root);
+			h(child).backlink = nullptr;
+			_root = _collapse(child);
+		}else{
+			_root = nullptr;
+		}
+	}
+
+	void remove(T *element) {
+		if(_root == element) {
+			pop();
+		}else{
+			auto predecessor = h(element).backlink;
+			auto sibling = h(element).sibling;
+			auto child = h(element).child;
+			FRG_ASSERT(predecessor);
+			
+			if(h(predecessor).child == element) {
+				h(predecessor).child = sibling;
+			}else{
+				FRG_ASSERT(h(predecessor).sibling == element);
+				h(predecessor).sibling = sibling;
+			}
+
+			if(sibling)
+				h(sibling).backlink = predecessor;
+
+			if(child) {
+				FRG_ASSERT(h(child).backlink == element);
+				h(child).backlink = nullptr;
+				_root = _merge(_root, _collapse(child));
+			}
+
+			h(element).backlink = nullptr;
+			h(element).sibling = nullptr;
+			h(element).child = nullptr;
+		}
+	}
+
+	T *top() {
+		return _root;
+	}
+
+private:
+	T *_root;
+};
+
+} // namespace _pairing
+
+using _pairing::pairing_heap_hook;
+using _pairing::pairing_heap;
+
+} // namespace frg
+
+#endif // FRG_PAIRING_HEAP_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/qs.hpp b/mlibc/subprojects/frigg/include/frg/qs.hpp
new file mode 100644
index 0000000..dd75878
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/qs.hpp
@@ -0,0 +1,254 @@
+#ifndef FRG_QS_HPP
+#define FRG_QS_HPP
+
+#include <stdint.h>
+#include <atomic>
+#include <type_traits>
+#include <utility>
+#include <frg/list.hpp>
+#include <frg/macros.hpp>
+#include <frg/utility.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename M>
+struct lock_guard {
+	lock_guard(M &m)
+	: _mutex{&m}, _locked{false} {
+		lock();
+	}
+
+	lock_guard(const lock_guard &) = delete;
+
+	lock_guard &operator= (const lock_guard &) = delete;
+
+	~lock_guard() {
+		if(_locked)
+			unlock();
+	}
+
+	void lock() {
+		FRG_ASSERT(!_locked);
+		_mutex->lock();
+		_locked = true;
+	}
+
+	void unlock() {
+		FRG_ASSERT(_locked);
+		_mutex->lock();
+		_locked = false;
+	}
+
+private:
+	M *_mutex;
+	bool _locked;
+};
+
+template<typename M>
+struct qs_agent;
+
+template<typename M>
+struct qs_domain {
+	friend struct qs_agent<M>;
+
+	qs_domain()
+	: _qs_counter{1}, _desired_qs_counter{0}, _num_agents{0}, _agents_to_ack{0} { }
+
+private:
+	M _mutex;
+
+	// Counter that is incremented each time all agents "ack".
+	// We abstractly call it the "QS counter".
+	// Write-protected by _mutex.
+	std::atomic<uint64_t> _qs_counter;
+
+	// Desired value of the QS counter.
+	// Can be accessed lock-free as it is only ever incremented.
+	std::atomic<uint64_t> _desired_qs_counter;
+
+	// Protected by _mutex.
+	unsigned int _num_agents;
+
+	// Number of agents that still need to ack until the QS counter is incremented.
+	// Each agents tracks (via a load-acquire on the QS counter) if it still needs to decrement this.
+	// Reset-protected by _mutex.
+	std::atomic<unsigned int> _agents_to_ack;
+};
+
+struct qs_node {
+	template<typename M>
+	friend struct qs_agent;
+
+	qs_node()
+	: on_grace_period{nullptr}, _target_qs_counter{0} { }
+
+	void (*on_grace_period)(qs_node *);
+
+private:
+	// Value of the QS counter at which the callback can be called.
+	uint64_t _target_qs_counter;
+
+	frg::default_list_hook<qs_node> _queue_node;
+};
+
+template<typename M>
+struct qs_agent {
+	qs_agent(qs_domain<M> *dom)
+	: _dom{dom}, _acked_qs_counter{0}, _qs_deferred{false} {
+		online();
+	}
+
+	void online() {
+		assert(!_acked_qs_counter);
+
+		uint64_t ctr;
+		{
+			lock_guard<M> lock(_dom->_mutex);
+
+			_dom->_num_agents++;
+//			std::cout << "Now there are " << _dom->_num_agents << " agents" << std::endl;
+
+			// Increment the QS counter if we're the first agent.
+			ctr = _dom->_qs_counter.load(std::memory_order_relaxed);
+			if(_dom->_num_agents == 1) {
+				assert(!_dom->_agents_to_ack.load(std::memory_order_relaxed));
+				_dom->_agents_to_ack.store(1, std::memory_order_relaxed);
+				_dom->_qs_counter.store(ctr + 1, std::memory_order_release);
+			}
+		}
+
+		_acked_qs_counter = ctr;
+	}
+
+	void offline() {
+		assert(_acked_qs_counter);
+
+		// TODO: We need to handle this case here.
+		assert(!_qs_deferred);
+
+		{
+			lock_guard<M> lock(_dom->_mutex);
+			
+			_dom->_num_agents--;
+
+			// We might need to ack before going offline.
+			auto ctr = _dom->_qs_counter.load(std::memory_order_relaxed);
+			if(_acked_qs_counter != ctr) {
+				assert(_acked_qs_counter + 1 == ctr);
+
+				// Now ack the QS.
+				if(_dom->_agents_to_ack.fetch_sub(1, std::memory_order_relaxed) == 1) {
+					_dom->_agents_to_ack.store(_dom->_num_agents, std::memory_order_relaxed);
+					_dom->_qs_counter.store(ctr + 1, std::memory_order_release);
+				}
+			}
+		}
+
+		_acked_qs_counter = 0;
+	}
+
+	void quiescent_state() {
+		assert(_acked_qs_counter);
+
+		if(_qs_deferred) {
+			assert(_acked_qs_counter == _dom->_qs_counter.load(std::memory_order_relaxed));
+
+			auto desired = _dom->_desired_qs_counter.load(std::memory_order_relaxed);
+			if(desired > _acked_qs_counter) {
+				lock_guard<M> lock(_dom->_mutex);
+//				std::cout << "Deferred QS " << (_acked_qs_counter + 1) << ". Resetting ack counter to " << _dom->_num_agents << std::endl;
+				_dom->_agents_to_ack.store(_dom->_num_agents, std::memory_order_relaxed);
+				_dom->_qs_counter.store(_acked_qs_counter + 1, std::memory_order_release);
+
+				_qs_deferred = false;
+			}
+		}else{
+			// Check if the QS counter incremented concurrently.
+			auto ctr = _dom->_qs_counter.load(std::memory_order_acquire);
+			if(_acked_qs_counter != ctr) {
+				assert(_acked_qs_counter + 1 == ctr);
+
+				// Now ack the QS.
+				if(_dom->_agents_to_ack.fetch_sub(1, std::memory_order_relaxed) == 1) {
+					auto desired = _dom->_desired_qs_counter.load(std::memory_order_relaxed);
+					if(desired > ctr) {
+						lock_guard<M> lock(_dom->_mutex);
+//						std::cout << "QS " << (ctr + 1) << ". Resetting ack counter to " << _dom->_num_agents << std::endl;
+						_dom->_agents_to_ack.store(_dom->_num_agents, std::memory_order_relaxed);
+						_dom->_qs_counter.store(ctr + 1, std::memory_order_release);
+					}else{
+						_qs_deferred = true;
+					}
+				}
+
+				_acked_qs_counter++;
+			}
+		}
+	}
+
+	void quiescent_barrier() {
+		// Advance the desired QS counter.
+		auto target = _dom->_qs_counter.load(std::memory_order_relaxed) + 2;
+		auto c = _dom->_desired_qs_counter.load(std::memory_order_relaxed);
+		while(c < target) {
+			if(_dom->_desired_qs_counter.compare_exchange_weak(c, target,
+					std::memory_order_relaxed, std::memory_order_relaxed))
+				break;
+		}
+
+		while(_dom->_qs_counter.load(std::memory_order_relaxed) < target) {
+			quiescent_state();
+		}
+	}
+
+	void await_barrier(qs_node *node) {
+		// Advance the desired QS counter.
+		auto target = _dom->_qs_counter.load(std::memory_order_relaxed) + 2;
+		auto c = _dom->_desired_qs_counter.load(std::memory_order_relaxed);
+		while(c < target) {
+			if(_dom->_desired_qs_counter.compare_exchange_weak(c, target,
+					std::memory_order_relaxed, std::memory_order_relaxed))
+				break;
+		}
+
+		assert(!node->_target_qs_counter);
+		node->_target_qs_counter = target;
+		_pending.push_back(node);
+	}
+
+	void run() {
+		auto ctr = _dom->_qs_counter.load(std::memory_order_relaxed);
+		while(!_pending.empty()) {
+			auto node = _pending.front();
+			if(ctr < node->_target_qs_counter)
+				break;
+			node->_target_qs_counter = 0;
+			node->on_grace_period(node);
+			_pending.pop_front();
+		}
+	}
+
+private:
+	qs_domain<M> *_dom;
+
+	// If this value equals the QS counter we already acked.
+	uint64_t _acked_qs_counter;
+
+	// True if this agent was the last one to ack a QS and then decided to defer it.
+	// This is an optimization to prevent agents from rapidly issuing QSs
+	// (as incrementing the QS counter requires taking a lock and thus impacts performance).
+	bool _qs_deferred;
+
+	frg::intrusive_list<
+		qs_node,
+		frg::locate_member<
+			qs_node,
+			frg::default_list_hook<qs_node>,
+			&qs_node::_queue_node
+		>
+	> _pending;
+};
+
+} // namespace frg
+
+#endif // FRG_QS_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/random.hpp b/mlibc/subprojects/frigg/include/frg/random.hpp
new file mode 100644
index 0000000..7e36417
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/random.hpp
@@ -0,0 +1,68 @@
+#ifndef FRG_RANDOM_HPP
+#define FRG_RANDOM_HPP
+
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+// Adopted from the Mersenne Twister reference implementation.
+// Copyright of the reference implementation:
+// (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura.
+// This struct is under the BSD licence.
+struct mt19937 {
+private:
+	static constexpr int n = 624;
+	static constexpr int m = 397;
+	static constexpr uint32_t matrix_a = 0x9908b0df;
+	static constexpr uint32_t msb = 0x80000000;
+	static constexpr uint32_t lsbs = 0x7fffffff;
+
+public:
+	mt19937() {
+		seed(5489);
+	}
+
+	void seed(uint32_t s) {
+		_st[0] = s;
+		for(_ctr = 1; _ctr < n; _ctr++)
+			_st[_ctr] = (1812433253 * (_st[_ctr - 1] ^ (_st[_ctr - 1] >> 30)) + _ctr);
+	}
+
+	uint32_t operator() () {
+		constexpr uint32_t mag01[2] = {0, matrix_a};
+
+		if(_ctr >= n) {
+			for(int kk = 0; kk < n - m; kk++) {
+				uint32_t y = (_st[kk] & msb) | (_st[kk + 1] & lsbs);
+				_st[kk] = _st[kk + m] ^ (y >> 1) ^ mag01[y & 1];
+			}
+
+			for(int kk = n - m; kk < n - 1; kk++) {
+				uint32_t y = (_st[kk] & msb) | (_st[kk + 1] & lsbs);
+				_st[kk] = _st[kk + (m - n)] ^ (y >> 1) ^ mag01[y & 1];
+			}
+
+			uint32_t y = (_st[n - 1] & msb) | (_st[0] & lsbs);
+			_st[n - 1] = _st[m - 1] ^ (y >> 1) ^ mag01[y & 1];
+
+			_ctr = 0;
+		}
+
+		uint32_t res = _st[_ctr++];
+
+		res ^= (res >> 11);
+		res ^= (res << 7) & 0x9d2c5680;
+		res ^= (res << 15) & 0xefc60000;
+		res ^= (res >> 18);
+
+		return res;
+	}
+
+private:
+	uint32_t _st[n];
+	int _ctr;
+};
+
+} // namespace frg
+
+#endif // FRG_RANDOM_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/rbtree.hpp b/mlibc/subprojects/frigg/include/frg/rbtree.hpp
new file mode 100644
index 0000000..3f47011
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/rbtree.hpp
@@ -0,0 +1,755 @@
+#ifndef FRG_RBTREE_HPP
+#define FRG_RBTREE_HPP
+
+#include <utility>
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+namespace _redblack {
+
+namespace {
+	constexpr bool enable_checking = false;
+};
+
+enum class color_type {
+	null, red, black
+};
+
+struct hook_struct {
+	hook_struct()
+	: parent(nullptr), left(nullptr), right(nullptr),
+			predecessor(nullptr), successor(nullptr),
+			color(color_type::null) { }
+
+	hook_struct(const hook_struct &other) = delete;
+
+	hook_struct &operator= (const hook_struct &other) = delete;
+
+	void *parent;
+	void *left;
+	void *right;
+	void *predecessor;
+	void *successor;
+	color_type color;
+};
+
+struct null_aggregator {
+	template<typename T>
+	static bool aggregate(T *node) {
+		(void)node;
+		return false;
+	}
+
+	template<typename S, typename T>
+	static bool check_invariant(S &tree, T *node) {
+		(void)tree;
+		(void)node;
+		return true;
+	}
+};
+
+template<typename D, typename T, hook_struct T:: *Member, typename A>
+struct tree_crtp_struct {
+protected:
+	// Obtain a pointer to the hook from a pointer to a node.
+	static hook_struct *h(T *item) {
+		return &(item->*Member);
+	}
+
+public:
+	static T *get_parent(T *item) {
+		return static_cast<T *>(h(item)->parent);
+	}
+
+	// TODO: rename to left()/right()?
+	static T *get_left(T *item) {
+		return static_cast<T *>(h(item)->left);
+	}
+	static T *get_right(T *item) {
+		return static_cast<T *>(h(item)->right);
+	}
+
+	static T *predecessor(T *item) {
+		return static_cast<T *>(h(item)->predecessor);
+	}
+	static T *successor(T *item) {
+		return static_cast<T *>(h(item)->successor);
+	}
+
+	T *get_root() {
+		return static_cast<T *>(_root);
+	}
+
+private:
+	static bool isRed(T *node) {
+		if(!node)
+			return false;
+		return h(node)->color == color_type::red;
+	}
+	static bool isBlack(T *node) {
+		if(!node)
+			return true;
+		return h(node)->color == color_type::black;
+	}
+
+	// ------------------------------------------------------------------------
+	// Constructor, Destructor, operators.
+	// ------------------------------------------------------------------------
+public:
+	tree_crtp_struct()
+	: _root{nullptr} { }
+
+	tree_crtp_struct(const tree_crtp_struct &other) = delete;
+
+	tree_crtp_struct &operator= (const tree_crtp_struct &other) = delete;
+
+	// ------------------------------------------------------------------------
+	// Traversal functions.
+	// ------------------------------------------------------------------------
+
+	T *first() {
+		T *current = get_root();
+		if(!current)
+			return nullptr;
+		while(get_left(current))
+			current = get_left(current);
+		return current;
+	}
+
+	// ------------------------------------------------------------------------
+	// Insertion functions.
+	// ------------------------------------------------------------------------
+protected:
+	void insert_root(T *node) {
+		FRG_ASSERT(!_root);
+		_root = node;
+
+		aggregate_node(node);
+		fix_insert(node);
+		if(enable_checking)
+			FRG_ASSERT(check_invariant());
+	}
+
+	void insert_left(T *parent, T *node) {
+		FRG_ASSERT(parent);
+		FRG_ASSERT(!get_left(parent));
+
+		if(enable_checking)
+			FRG_ASSERT(check_invariant());
+
+		h(parent)->left = node;
+		h(node)->parent = parent;
+
+		// "parent" is the successor of "node"
+		T *pred = predecessor(parent);
+		if(pred)
+			h(pred)->successor = node;
+		h(node)->predecessor = pred;
+		h(node)->successor = parent;
+		h(parent)->predecessor = node;
+
+		aggregate_node(node);
+		aggregate_path(parent);
+		fix_insert(node);
+		if(enable_checking)
+			FRG_ASSERT(check_invariant());
+	}
+
+	void insert_right(T *parent, T *node) {
+		FRG_ASSERT(parent);
+		FRG_ASSERT(!get_right(parent));
+
+		if(enable_checking)
+			FRG_ASSERT(check_invariant());
+
+		h(parent)->right = node;
+		h(node)->parent = parent;
+
+		// "parent" is the predecessor of "node"
+		T *succ = successor(parent);
+		h(parent)->successor = node;
+		h(node)->predecessor = parent;
+		h(node)->successor = succ;
+		if(succ)
+			h(succ)->predecessor = node;
+
+		aggregate_node(node);
+		aggregate_path(parent);
+		fix_insert(node);
+		if(enable_checking)
+			FRG_ASSERT(check_invariant());
+	}
+
+	// Situation:
+	// |     (p)     |
+	// |    /   \    |
+	// |  (s)   (n)  |
+	// Precondition: The red-black property is only violated in the following sense:
+	//     Paths from (p) over (n) to a leaf contain one black node more
+	//     than paths from (p) over (s) to a leaf.
+	//     n itself might be either red or black.
+	// Postcondition: The red-black property is satisfied.
+private:
+	void fix_insert(T *n) {
+		T *parent = get_parent(n);
+		if(parent == nullptr) {
+			h(n)->color = color_type::black;
+			return;
+		}
+
+		// coloring n red is not a problem if the parent is black.
+		h(n)->color = color_type::red;
+		if(h(parent)->color == color_type::black)
+			return;
+
+		// the rb invariants guarantee that a grandparent exists
+		// (because parent is red and the root is black).
+		T *grand = get_parent(parent);
+		FRG_ASSERT(grand && h(grand)->color == color_type::black);
+
+		// if the node has a red uncle we can just color both the parent
+		// and the uncle black, the grandparent red and propagate upwards.
+		if(get_left(grand) == parent && isRed(get_right(grand))) {
+			h(grand)->color = color_type::red;
+			h(parent)->color = color_type::black;
+			h(get_right(grand))->color = color_type::black;
+
+			fix_insert(grand);
+			return;
+		}else if(get_right(grand) == parent && isRed(get_left(grand))) {
+			h(grand)->color = color_type::red;
+			h(parent)->color = color_type::black;
+			h(get_left(grand))->color = color_type::black;
+
+			fix_insert(grand);
+			return;
+		}
+
+		if(parent == get_left(grand)) {
+			if(n == get_right(parent)) {
+				rotateLeft(n);
+				rotateRight(n);
+				h(n)->color = color_type::black;
+			}else{
+				rotateRight(parent);
+				h(parent)->color = color_type::black;
+			}
+			h(grand)->color = color_type::red;
+		}else{
+			FRG_ASSERT(parent == get_right(grand));
+			if(n == get_left(parent)) {
+				rotateRight(n);
+				rotateLeft(n);
+				h(n)->color = color_type::black;
+			}else{
+				rotateLeft(parent);
+				h(parent)->color = color_type::black;
+			}
+			h(grand)->color = color_type::red;
+		}
+	}
+
+	// ------------------------------------------------------------------------
+	// Removal functions.
+	// ------------------------------------------------------------------------
+public:
+	void remove(T *node) {
+		if(enable_checking)
+			FRG_ASSERT(check_invariant());
+
+		T *left_ptr = get_left(node);
+		T *right_ptr = get_right(node);
+
+		if(!left_ptr) {
+			remove_half_leaf(node, right_ptr);
+		}else if(!right_ptr) {
+			remove_half_leaf(node, left_ptr);
+		}else{
+			// replace the node by its predecessor
+			T *pred = predecessor(node);
+			remove_half_leaf(pred, get_left(pred));
+			replace_node(node, pred);
+		}
+
+		if(enable_checking)
+			FRG_ASSERT(check_invariant());
+	}
+
+private:
+	// Replace the node (with is in the tree) by a replacement (which is not in the tree).
+	void replace_node(T *node, T *replacement) {
+		T *parent = get_parent(node);
+		T *left = get_left(node);
+		T *right = get_right(node);
+
+		// fix the red-black tree
+		if(parent == nullptr) {
+			_root = replacement;
+		}else if(node == get_left(parent)) {
+			h(parent)->left = replacement;
+		}else{
+			FRG_ASSERT(node == get_right(parent));
+			h(parent)->right = replacement;
+		}
+		h(replacement)->parent = parent;
+		h(replacement)->color = h(node)->color;
+
+		h(replacement)->left = left;
+		if(left)
+			h(left)->parent = replacement;
+
+		h(replacement)->right = right;
+		if(right)
+			h(right)->parent = replacement;
+
+		// fix the linked list
+		if(predecessor(node))
+			h(predecessor(node))->successor = replacement;
+		h(replacement)->predecessor = predecessor(node);
+		h(replacement)->successor = successor(node);
+		if(successor(node))
+			h(successor(node))->predecessor = replacement;
+
+		h(node)->left = nullptr;
+		h(node)->right = nullptr;
+		h(node)->parent = nullptr;
+		h(node)->predecessor = nullptr;
+		h(node)->successor = nullptr;
+
+		aggregate_node(replacement);
+		aggregate_path(parent);
+	}
+
+	void remove_half_leaf(T *node, T *child) {
+		T *pred = predecessor(node);
+		T *succ = successor(node);
+		if(pred)
+			h(pred)->successor = succ;
+		if(succ)
+			h(succ)->predecessor = pred;
+
+		if(h(node)->color == color_type::black) {
+			if(isRed(child)) {
+				h(child)->color = color_type::black;
+			}else{
+				// decrement the number of black nodes all paths through "node"
+				// before removing the child. this makes sure we're correct even when
+				// "child" is null
+				fix_remove(node);
+			}
+		}
+
+		FRG_ASSERT((!get_left(node) && get_right(node) == child)
+				|| (get_left(node) == child && !get_right(node)));
+
+		T *parent = get_parent(node);
+		if(!parent) {
+			_root = child;
+		}else if(get_left(parent) == node) {
+			h(parent)->left = child;
+		}else{
+			FRG_ASSERT(get_right(parent) == node);
+			h(parent)->right = child;
+		}
+		if(child)
+			h(child)->parent = parent;
+
+		h(node)->left = nullptr;
+		h(node)->right = nullptr;
+		h(node)->parent = nullptr;
+		h(node)->predecessor = nullptr;
+		h(node)->successor = nullptr;
+
+		if(parent)
+			aggregate_path(parent);
+	}
+
+	// Situation:
+	// |     (p)     |
+	// |    /   \    |
+	// |  (s)   (n)  |
+	// Precondition: The red-black property is only violated in the following sense:
+	//     Paths from (p) over (n) to a leaf contain one black node less
+	//     than paths from (p) over (s) to a leaf
+	// Postcondition: The whole tree is a red-black tree
+	void fix_remove(T *n) {
+		FRG_ASSERT(h(n)->color == color_type::black);
+
+		T *parent = get_parent(n);
+		if(parent == nullptr)
+			return;
+
+		// rotate so that our node has a black sibling
+		T *s; // this will always be the sibling of our node
+		if(get_left(parent) == n) {
+			FRG_ASSERT(get_right(parent));
+			if(h(get_right(parent))->color == color_type::red) {
+				T *x = get_right(parent);
+				rotateLeft(get_right(parent));
+				FRG_ASSERT(n == get_left(parent));
+
+				h(parent)->color = color_type::red;
+				h(x)->color = color_type::black;
+			}
+
+			s = get_right(parent);
+		}else{
+			FRG_ASSERT(get_right(parent) == n);
+			FRG_ASSERT(get_left(parent));
+			if(h(get_left(parent))->color == color_type::red) {
+				T *x = get_left(parent);
+				rotateRight(x);
+				FRG_ASSERT(n == get_right(parent));
+
+				h(parent)->color = color_type::red;
+				h(x)->color = color_type::black;
+			}
+
+			s = get_left(parent);
+		}
+
+		if(isBlack(get_left(s)) && isBlack(get_right(s))) {
+			if(h(parent)->color == color_type::black) {
+				h(s)->color = color_type::red;
+				fix_remove(parent);
+				return;
+			}else{
+				h(parent)->color = color_type::black;
+				h(s)->color = color_type::red;
+				return;
+			}
+		}
+
+		// now at least one of s children is red
+		auto parent_color = h(parent)->color;
+		if(get_left(parent) == n) {
+			// rotate so that get_right(s) is red
+			if(isRed(get_left(s)) && isBlack(get_right(s))) {
+				T *child = get_left(s);
+				rotateRight(child);
+
+				h(s)->color = color_type::red;
+				h(child)->color = color_type::black;
+
+				s = child;
+			}
+			FRG_ASSERT(isRed(get_right(s)));
+
+			rotateLeft(s);
+			h(parent)->color = color_type::black;
+			h(s)->color = parent_color;
+			h(get_right(s))->color = color_type::black;
+		}else{
+			FRG_ASSERT(get_right(parent) == n);
+
+			// rotate so that get_left(s) is red
+			if(isRed(get_right(s)) && isBlack(get_left(s))) {
+				T *child = get_right(s);
+				rotateLeft(child);
+
+				h(s)->color = color_type::red;
+				h(child)->color = color_type::black;
+
+				s = child;
+			}
+			FRG_ASSERT(isRed(get_left(s)));
+
+			rotateRight(s);
+			h(parent)->color = color_type::black;
+			h(s)->color = parent_color;
+			h(get_left(s))->color = color_type::black;
+		}
+	}
+
+	// ------------------------------------------------------------------------
+	// Rotation functions.
+	// ------------------------------------------------------------------------
+private:
+	// Left rotation (n denotes the given node):
+	//   w                 w        |
+	//   |                 |        |
+	//   u                 n        |
+	//  / \      -->      / \       |
+	// x   n             u   y      |
+	//    / \           / \         |
+	//   v   y         x   v        |
+	// Note that x and y are left unchanged.
+	void rotateLeft(T *n) {
+		T *u = get_parent(n);
+		FRG_ASSERT(u != nullptr && get_right(u) == n);
+		T *v = get_left(n);
+		T *w = get_parent(u);
+
+		if(v != nullptr)
+			h(v)->parent = u;
+		h(u)->right = v;
+		h(u)->parent = n;
+		h(n)->left = u;
+		h(n)->parent = w;
+
+		if(w == nullptr) {
+			_root = n;
+		}else if(get_left(w) == u) {
+			h(w)->left = n;
+		}else{
+			FRG_ASSERT(get_right(w) == u);
+			h(w)->right = n;
+		}
+
+		aggregate_node(u);
+		aggregate_node(n);
+	}
+
+	// Right rotation (n denotes the given node):
+	//     w             w          |
+	//     |             |          |
+	//     u             n          |
+	//    / \    -->    / \         |
+	//   n   x         y   u        |
+	//  / \               / \       |
+	// y   v             v   x      |
+	// Note that x and y are left unchanged.
+	void rotateRight(T *n) {
+		T *u = get_parent(n);
+		FRG_ASSERT(u != nullptr && get_left(u) == n);
+		T *v = get_right(n);
+		T *w = get_parent(u);
+
+		if(v != nullptr)
+			h(v)->parent = u;
+		h(u)->left = v;
+		h(u)->parent = n;
+		h(n)->right = u;
+		h(n)->parent = w;
+
+		if(w == nullptr) {
+			_root = n;
+		}else if(get_left(w) == u) {
+			h(w)->left = n;
+		}else{
+			FRG_ASSERT(get_right(w) == u);
+			h(w)->right = n;
+		}
+
+		aggregate_node(u);
+		aggregate_node(n);
+	}
+
+	// ------------------------------------------------------------------------
+	// Aggregation functions.
+	// ------------------------------------------------------------------------
+public:
+	void aggregate_node(T *node) {
+		A::aggregate(node);
+	}
+
+	void aggregate_path(T *node) {
+		T *current = node;
+		while(current) {
+			if(!A::aggregate(current))
+				break;
+			current = get_parent(current);
+		}
+	}
+
+	// ------------------------------------------------------------------------
+	// Invariant validation functions.
+	// ------------------------------------------------------------------------
+private:
+	bool check_invariant() {
+		if(!_root)
+			return true;
+
+		int black_depth;
+		T *minimal, *maximal;
+		return check_invariant(get_root(), black_depth, minimal, maximal);
+	}
+
+	bool check_invariant(T *node, int &black_depth, T *&minimal, T *&maximal) {
+		// check alternating colors invariant
+		if(h(node)->color == color_type::red)
+			if(!isBlack(get_left(node)) || !isBlack(get_right(node))) {
+//				infoLogger() << "Alternating colors violation" << endLog;
+				return false;
+			}
+
+		// check recursive invariants
+		int left_black_depth = 0;
+		int right_black_depth = 0;
+
+		if(get_left(node)) {
+//			if(_less(*node, *get_left(node))) {
+//				infoLogger() << "Binary search tree (left) violation" << endLog;
+//				return false;
+//			}
+
+			T *pred;
+			if(!check_invariant(get_left(node), left_black_depth, minimal, pred))
+				return false;
+
+			// check predecessor invariant
+			if(successor(pred) != node) {
+//				infoLogger() << "Linked list (predecessor, forward) violation" << endLog;
+				return false;
+			}else if(predecessor(node) != pred) {
+//				infoLogger() << "Linked list (predecessor, backward) violation" << endLog;
+				return false;
+			}
+		}else{
+			minimal = node;
+		}
+
+		if(get_right(node)) {
+//			if(_less(*get_right(node), *node)) {
+//				infoLogger() << "Binary search tree (right) violation" << endLog;
+//				return false;
+//			}
+
+			T *succ;
+			if(!check_invariant(get_right(node), right_black_depth, succ, maximal))
+				return false;
+
+			// check successor invariant
+			if(successor(node) != succ) {
+//				infoLogger() << "Linked list (successor, forward) violation" << endLog;
+				return false;
+			}else if(predecessor(succ) != node) {
+//				infoLogger() << "Linked list (successor, backward) violation" << endLog;
+				return false;
+			}
+		}else{
+			maximal = node;
+		}
+
+		// check black-depth invariant
+		if(left_black_depth != right_black_depth) {
+//			infoLogger() << "Black-depth violation" << endLog;
+			return false;
+		}
+		black_depth = left_black_depth;
+		if(h(node)->color == color_type::black)
+			black_depth++;
+
+		if(!A::check_invariant(*static_cast<D *>(this), node))
+			return false;
+
+		return true;
+	}
+
+private:
+	void *_root;
+};
+
+template<typename T, hook_struct T:: *Member, typename L, typename A>
+struct tree_struct : tree_crtp_struct<tree_struct<T, Member, L, A>, T, Member, A> {
+private:
+	using tree_crtp_struct<tree_struct<T, Member, L, A>, T, Member, A>::insert_root;
+	using tree_crtp_struct<tree_struct<T, Member, L, A>, T, Member, A>::insert_left;
+	using tree_crtp_struct<tree_struct<T, Member, L, A>, T, Member, A>::insert_right;
+public:
+	using tree_crtp_struct<tree_struct<T, Member, L, A>, T, Member, A>::get_left;
+	using tree_crtp_struct<tree_struct<T, Member, L, A>, T, Member, A>::get_right;
+	using tree_crtp_struct<tree_struct<T, Member, L, A>, T, Member, A>::get_root;
+
+	// ------------------------------------------------------------------------
+	// Constructor, Destructor, operators.
+	// ------------------------------------------------------------------------
+public:
+	tree_struct(L less = L())
+	: _less{std::move(less)} { }
+
+	// ------------------------------------------------------------------------
+	// Insertion functions.
+	// ------------------------------------------------------------------------
+public:
+	void insert(T *node) {
+		if(!get_root()) {
+			insert_root(node);
+			return;
+		}
+
+		T *current = get_root();
+		while(true) {
+			if(_less(*node, *current)) {
+				if(get_left(current) == nullptr) {
+					insert_left(current, node);
+					return;
+				}else{
+					current = get_left(current);
+				}
+			}else{
+				if(get_right(current) == nullptr) {
+					insert_right(current, node);
+					return;
+				}else{
+					current = get_right(current);
+				}
+			}
+		}
+	}
+
+private:
+	L _less;
+};
+
+// This RB tree variant does not have a comparator but stores the elements in
+// the same order in which they are inserted.
+template<typename T, hook_struct T:: *Member, typename A>
+struct tree_order_struct : tree_crtp_struct<tree_order_struct<T, Member, A>, T, Member, A> {
+private:
+	using tree_crtp_struct<tree_order_struct<T, Member, A>, T, Member, A>::insert_root;
+	using tree_crtp_struct<tree_order_struct<T, Member, A>, T, Member, A>::insert_left;
+	using tree_crtp_struct<tree_order_struct<T, Member, A>, T, Member, A>::insert_right;
+public:
+	using tree_crtp_struct<tree_order_struct<T, Member, A>, T, Member, A>::get_left;
+	using tree_crtp_struct<tree_order_struct<T, Member, A>, T, Member, A>::get_right;
+	using tree_crtp_struct<tree_order_struct<T, Member, A>, T, Member, A>::get_root;
+
+	// ------------------------------------------------------------------------
+	// Insertion functions.
+	// ------------------------------------------------------------------------
+public:
+	void insert(T *before, T *node) {
+		if(!before) {
+			// Insert as last element.
+			T *current = get_root();
+			if(!current) {
+				insert_root(node);
+				return;
+			}
+
+			while(get_right(current)) {
+				current = get_right(current);
+			}
+			insert_right(current, node);
+		}else {
+			// Insert before the given element.
+			T *current = get_left(before);
+			if(!current) {
+				insert_left(before, node);
+				return;
+			}
+
+			while(get_right(current)) {
+				current = get_right(current);
+			}
+			insert_right(current, node);
+		}
+	}
+};
+
+} // namespace _redblack
+
+using rbtree_hook = _redblack::hook_struct;
+using null_aggregator = _redblack::null_aggregator;
+
+template<typename T, rbtree_hook T:: *Member, typename L, typename A = null_aggregator>
+using rbtree = _redblack::tree_struct<T, Member, L, A>;
+
+template<typename T, rbtree_hook T:: *Member, typename A = null_aggregator>
+using rbtree_order = _redblack::tree_order_struct<T, Member, A>;
+
+} // namespace frg
+
+#endif // FRG_RBTREE_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/rcu_radixtree.hpp b/mlibc/subprojects/frigg/include/frg/rcu_radixtree.hpp
new file mode 100644
index 0000000..09c1ce9
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/rcu_radixtree.hpp
@@ -0,0 +1,359 @@
+#ifndef FRG_RCU_RADIXTREE_HPP
+#define FRG_RCU_RADIXTREE_HPP
+
+#include <stdint.h>
+#include <atomic>
+#include <new>
+#include <frg/allocation.hpp>
+#include <frg/eternal.hpp>
+#include <frg/macros.hpp>
+#include <frg/tuple.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename T, typename Allocator>
+struct rcu_radixtree {
+private:
+	static constexpr unsigned int ll = 15;
+
+	uint64_t pfx_of(uint64_t k, unsigned int d) {
+		return k & (uint64_t(-1) << (64 - d * 4));
+	}
+
+	unsigned int idx_of(uint64_t k, unsigned int d) {
+		return (k >> (64 - (d + 1) * 4) & 0xF);
+	}
+
+	struct link_node;
+	struct entry_node;
+
+	struct node {
+		uint64_t prefix;
+		unsigned int depth;
+		link_node *parent;
+	};
+
+	struct link_node : node {
+		std::atomic<node *> links[16];
+	};
+
+	struct entry_node : node {
+		std::atomic<uint16_t> mask;
+		aligned_storage<sizeof(T), alignof(T)> entries[16];
+	};
+
+public:
+	rcu_radixtree(Allocator allocator = Allocator())
+	: _allocator{std::move(allocator)}, _root{nullptr} {}
+
+	rcu_radixtree(const rcu_radixtree &) = delete;
+
+	~rcu_radixtree() {
+		node *n = _root;
+		_root = nullptr;
+
+		while(n) {
+			node *tn = nullptr;
+			if(n->depth == ll) {
+				auto cn = static_cast<entry_node *>(n);
+
+				auto mask = cn->mask.load(std::memory_order_relaxed);
+				for(int idx = 0; idx < 16; ++idx) {
+					if(!(mask & (uint16_t(1) << idx)))
+						continue;
+					auto p = std::launder(reinterpret_cast<T *>(cn->entries[idx].buffer));
+					p->~T();
+				}
+
+				tn = cn->parent;
+				frg::destruct(_allocator, cn);
+			}else{
+				auto cn = static_cast<link_node *>(n);
+
+				// If this link_node still has children, delete them first.
+				for(int idx = 0; idx < 16; ++idx) {
+					if(cn->links[idx]) {
+						tn = cn->links[idx];
+						cn->links[idx] = nullptr;
+						break;
+					}
+				}
+
+				// When this link_node is a leaf, delete it.
+				if(!tn) {
+					tn = cn->parent;
+					frg::destruct(_allocator, cn);
+				}
+			}
+			n = tn;
+		}
+	}
+
+	rcu_radixtree &operator= (const rcu_radixtree &) = delete;
+
+	T *find(uint64_t k) {
+		auto n = _root.load(std::memory_order_acquire);
+		while(true) {
+			if(!n)
+				return nullptr;
+			if(pfx_of(k, n->depth) != n->prefix)
+				return nullptr;
+
+			auto idx = idx_of(k, n->depth);
+			if(n->depth == ll) {
+				auto cn = static_cast<entry_node *>(n);
+				auto mask = cn->mask.load(std::memory_order_acquire);
+				if(!(mask & (uint16_t(1) << idx)))
+					return nullptr;
+				return std::launder(reinterpret_cast<T *>(cn->entries[idx].buffer));
+			}else{
+				auto cn = static_cast<link_node *>(n); 
+				n = cn->links[idx].load(std::memory_order_acquire);
+			}
+		}
+	}
+
+	template<typename... Args>
+	tuple<T *, bool> find_or_insert(uint64_t k, Args &&... args) {
+		// p will be the node that we insert into.
+		link_node *p = nullptr;
+		node *s = _root.load(std::memory_order_acquire);
+		while(true) {
+			// First case: We insert a last-level node into an inner node.
+			if(!s) {
+//				std::cout << "Case 1" << std::endl;
+				auto n = construct<entry_node>(_allocator);
+				n->prefix = pfx_of(k, ll);
+				n->depth = ll;
+				n->parent = p;
+				n->mask.store(uint16_t(1) << idx_of(k, ll), std::memory_order_relaxed);
+
+				auto entry = new (n->entries[idx_of(k, ll)].buffer) T{std::forward<Args>(args)...};
+
+				if(p) {
+					auto cp = static_cast<link_node *>(p);
+					cp->links[idx_of(k, p->depth)].store(n, std::memory_order_release);
+				}else{
+					_root.store(n, std::memory_order_release);
+				}
+				return {entry, true};
+			}
+
+			// Second case: We insert a new inner node and a last-level node.
+			// s is the sibling of the new last-level node.
+			if(pfx_of(k, s->depth) != s->prefix) {
+//				std::cout << "Case 2" << std::endl;
+				auto n = construct<entry_node>(_allocator);
+				auto r = construct<link_node>(_allocator);
+
+				n->prefix = pfx_of(k, ll);
+				n->depth = ll;
+				n->parent = r;
+				n->mask.store(uint16_t(1) << idx_of(k, ll), std::memory_order_relaxed);
+
+				auto entry = new (n->entries[idx_of(k, ll)].buffer) T{std::forward<Args>(args)...};
+
+				s->parent = r;
+
+				// Determine the common prefix of k and s->prefix.
+				unsigned int d = 0;
+				while(pfx_of(k, d + 1) == pfx_of(s->prefix, d + 1))
+					d++;
+				FRG_ASSERT(!p || d > p->depth);
+				FRG_ASSERT(d < s->depth);
+				FRG_ASSERT(idx_of(k, d) != idx_of(s->prefix, d));
+//				std::cout << "d = " << d << std::endl;
+
+				r->prefix = pfx_of(k, d);
+				r->depth = d;
+				r->parent = p;
+				for(int i = 0; i < 16; ++i)
+					r->links[i].store(nullptr, std::memory_order_relaxed);
+				r->links[idx_of(k, d)].store(n, std::memory_order_relaxed);
+				r->links[idx_of(s->prefix, d)].store(s, std::memory_order_relaxed);
+//				std::cout << "idx: " << idx_of(k, d) << " and " << idx_of(s->prefix, d) << std::endl;
+
+				if(p) {
+					auto cp = static_cast<link_node *>(p);
+					cp->links[idx_of(k, p->depth)].store(r, std::memory_order_release);
+				}else{
+					_root.store(r, std::memory_order_release);
+				}
+				return {entry, true};
+			}
+
+			// Third case: We directly insert into a last-level node.
+			auto idx = idx_of(k, s->depth);
+			if(s->depth == ll) {
+//				std::cout << "Case 3" << std::endl;
+				auto cs = static_cast<entry_node *>(s);
+				auto mask = cs->mask.load(std::memory_order_acquire);
+				if(mask & (uint16_t(1) << idx))
+					return {std::launder(reinterpret_cast<T *>(cs->entries[idx].buffer)), false};
+
+				auto entry = new (cs->entries[idx].buffer) T{std::forward<Args>(args)...};
+
+				cs->mask.store(mask | (uint16_t(1) << idx), std::memory_order_release);
+				return {entry, true};
+			}else{
+				auto cs = static_cast<link_node *>(s);
+				p = cs;
+				s = static_cast<node *>(cs->links[idx].load(std::memory_order_acquire));
+			}
+		}
+	}
+
+	template<typename... Args>
+	T *insert(uint64_t k, Args &&... args) {
+		auto ins = find_or_insert(k, std::forward<Args>(args)...);
+		FRG_ASSERT(ins.template get<1>());
+		return ins.template get<0>();
+	}
+
+	void erase(uint64_t k) {
+		auto n = _root.load(std::memory_order_acquire);
+		while(true) {
+			FRG_ASSERT(n);
+			FRG_ASSERT(pfx_of(k, n->depth) == n->prefix);
+
+			auto idx = idx_of(k, n->depth);
+			if(n->depth == ll) {
+				auto cn = static_cast<entry_node *>(n);
+				auto mask = cn->mask.load(std::memory_order_acquire);
+				FRG_ASSERT(mask & (uint16_t(1) << idx));
+
+				cn->mask.store(mask & ~(uint16_t(1) << idx), std::memory_order_release);
+				return;
+			}else{
+				auto cn = static_cast<link_node *>(n);
+				n = static_cast<node *>(cn->links[idx].load(std::memory_order_acquire));
+			}
+		}
+	}
+
+private:
+	// Helper function for iteration.
+	static entry_node *first_leaf(node *n) {
+		if(!n)
+			return nullptr;
+		while(true) {
+			if(n->depth == ll)
+				return static_cast<entry_node *>(n);
+
+			auto cn = static_cast<link_node *>(n);
+
+			node *m = nullptr;
+			for(unsigned int idx = 0; idx < 16; idx++) {
+				m = cn->links[idx].load(std::memory_order_relaxed);
+				if(m)
+					break;
+			}
+			FRG_ASSERT(m);
+			n = m;
+		}
+	}
+
+	// Helper function for iteration.
+	static entry_node *next_leaf(node *n) {
+		while(true) {
+			auto p = n->parent;
+			if(!p)
+				return nullptr;
+
+			// Find the index of n in its parent.
+			unsigned int pidx;
+			for(pidx = 0; pidx < 16; pidx++) {
+				if(n == p->links[pidx].load(std::memory_order_relaxed))
+					break;
+			}
+			FRG_ASSERT(pidx < 16);
+
+			// Check if there is a sibling.
+			for(unsigned int idx = pidx + 1; idx < 16; idx++) {
+				auto m = p->links[idx].load(std::memory_order_relaxed);
+				if(m)
+					return first_leaf(m);
+			}
+
+			n = p;
+		}
+	}
+
+public:
+	// Note: The iterator interface is *not* safe in the presence of concurrent modification.
+	//       Only use this interface while there are no concurrent writers.
+	struct iterator {
+		explicit iterator()
+		: _n{nullptr}, _idx{16} { }
+
+		explicit iterator(entry_node *n, unsigned int idx)
+		: _n{n}, _idx{idx} { }
+
+		void operator++ () {
+			FRG_ASSERT(_idx < 16);
+			_idx++;
+
+			while(true) {
+				// Try to find a present entry.
+				auto mask = _n->mask.load(std::memory_order_relaxed);
+				while(_idx < 16) {
+					if(mask & (1 << _idx))
+						return;
+					_idx++;
+				}
+
+				// Inspect the next leaf instead.
+				_n = next_leaf(_n);
+				if(!_n)
+					return;
+				_idx = 0;
+			}
+		}
+
+		T &operator* () {
+			return *std::launder(reinterpret_cast<T *>(_n->entries[_idx].buffer));
+		}
+		T *operator-> () {
+			return std::launder(reinterpret_cast<T *>(_n->entries[_idx].buffer));
+		}
+
+		bool operator== (const iterator &other) const {
+			return _n == other._n && _idx == other._idx;
+		}
+		bool operator!= (const iterator &other) const {
+			return !(*this == other);
+		}
+
+	private:
+		entry_node *_n;
+		unsigned int _idx;
+	};
+
+	iterator begin() {
+		auto n = first_leaf(_root.load(std::memory_order_relaxed));
+		while(true) {
+			if(!n)
+				return iterator{};
+
+			// Try to find a present entry.
+			for(unsigned int idx = 0; idx < 16; idx++) {
+				if(n->mask.load(std::memory_order_relaxed) & (1 << idx))
+					return iterator{n, idx};
+			}
+
+			n = next_leaf(n);
+		}
+	}
+
+	iterator end() {
+		return iterator{};
+	}
+
+private:
+	Allocator _allocator;
+	std::atomic<node *> _root;
+};
+
+} // namespace frg
+
+#endif // FRG_RCU_RADIXTREE_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/slab.hpp b/mlibc/subprojects/frigg/include/frg/slab.hpp
new file mode 100644
index 0000000..e46a763
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/slab.hpp
@@ -0,0 +1,751 @@
+#pragma once
+
+#include <stddef.h>
+#include <stdint.h>
+#include <string.h>
+#include <frg/macros.hpp>
+#include <frg/mutex.hpp>
+#include <frg/rbtree.hpp>
+#include <frg/detection.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+namespace {
+	// TODO: We need a frigg logging mechanism to enable this.
+	//constexpr bool logAllocations = true;
+
+	constexpr bool enable_checking = false;
+}
+
+template<typename T>
+struct bitop_impl;
+
+template<>
+struct bitop_impl<unsigned long> {
+	static constexpr int clz(unsigned long x) {
+		return __builtin_clzl(x);
+	}
+};
+
+template<>
+struct bitop_impl<unsigned int> {
+	static constexpr int clz(unsigned int x) {
+		return __builtin_clz(x);
+	}
+};
+
+template<typename T, size_t N>
+constexpr size_t array_size(const T (&)[N]) {
+	return N;
+}
+
+template<typename Policy>
+using policy_slabsize_t = decltype(Policy::slabsize);
+
+template<typename Policy>
+using policy_pagesize_t = decltype(Policy::pagesize);
+
+template<typename Policy>
+using policy_num_buckets_t = decltype(Policy::num_buckets);
+
+template<typename Policy>
+using policy_output_trace_t = decltype(std::declval<Policy>().output_trace(uint8_t(0)));
+
+template<typename Policy>
+using policy_walk_stack_t = decltype(std::declval<Policy>().walk_stack(std::declval<void(uintptr_t)>()));
+
+template<typename Policy>
+using policy_poison_t = decltype(std::declval<Policy>().poison(nullptr, size_t(0)));
+
+template<typename Policy>
+using policy_enable_trace_t = decltype(std::declval<Policy>().enable_trace());
+
+template<typename Policy>
+using policy_map_aligned_t = decltype(std::declval<Policy>().map(size_t(0), size_t(0)));
+
+template<typename Policy, typename Mutex>
+class slab_pool {
+public:
+	slab_pool(Policy &plcy);
+
+	slab_pool(const slab_pool &) = delete;
+
+	slab_pool &operator= (const slab_pool &) = delete;
+
+	void *allocate(size_t length);
+	void *realloc(void *pointer, size_t new_length);
+	void free(void *pointer);
+	void deallocate(void *pointer, size_t size);
+
+	size_t numUsedPages() {
+		return _usedPages;
+	}
+
+private:
+	// The following variables configure the size of the buckets.
+	// Bucket size increases both with small_base_exp and small_step_exp. Furthermore,
+	// small_step_exp controls how many buckets are between any two power-of-2 buckets.
+	// The first bucket has a size of size_t(1) << (small_base_exp + small_step_exp).
+	// This approach is taken from jemalloc.
+#ifdef __clang__
+	static constexpr size_t tiny_sizes[4] = {8, 16, 32, 64};
+#else
+	static constexpr size_t tiny_sizes[] = {8, 16, 32, 64};
+#endif
+	static constexpr unsigned int small_base_exp = 6;
+	static constexpr unsigned int small_step_exp = 0;
+
+	static_assert(tiny_sizes[array_size(tiny_sizes) - 1]
+			== (static_cast<size_t>(1) << (small_base_exp + small_step_exp)),
+		"Last tiny bucket must match first small bucket");
+
+	// Computes the size of a given bucket.
+	static constexpr size_t bucket_to_size(unsigned int idx) {
+		// First, we handle the hard-coded tiny sizes.
+		auto tc = array_size(tiny_sizes);
+		if(idx < tc)
+			return tiny_sizes[idx];
+
+		// Next, we handle the small sizes.
+		auto s = 1 << small_step_exp;
+		auto ip = (idx - tc + 1) >> small_step_exp;
+		auto is = (idx - tc + 1) & (s - 1);
+		auto f = small_base_exp + ip;
+		return static_cast<size_t>(s + is) << f;
+	}
+
+	// The "inverse" of bucket_to_size().
+	static constexpr size_t size_to_bucket(size_t size) {
+		// First, we handle the hard-coded tiny sizes.
+		auto tc = array_size(tiny_sizes);
+		if(size <= bucket_to_size(tc - 1)) {
+			for(unsigned int i = 0; i < tc - 1; i++)
+				if(size <= bucket_to_size(i))
+					return i;
+			return tc - 1;
+		}
+
+		// Next, we handle the small sizes. Variables correspond to those in bucket_to_size().
+		auto e = (sizeof(size_t) * 8 - 1) - bitop_impl<size_t>::clz(size);
+		auto f = e - small_step_exp;
+		auto ip = ((f - small_base_exp) << small_step_exp);
+		auto is = ((size - (static_cast<size_t>(1) << e)) + (static_cast<size_t>(1) << f) - 1) >> f;
+		return tc - 1 + ip + is;
+	}
+
+	// This variable controls the number of buckets that we actually use.
+	static constexpr int num_buckets = [](){
+		if constexpr (is_detected_v<policy_num_buckets_t, Policy>)
+			return Policy::num_buckets;
+		else
+			return 13;
+	}();
+
+	static constexpr size_t max_bucket_size = bucket_to_size(num_buckets - 1);
+
+	// Here, we perform some compile-time verification of the bucket size calculation.
+	static constexpr bool test_bucket_calculation(unsigned int n) {
+		for(unsigned int i = 0; i < n; i++) {
+			if(size_to_bucket(bucket_to_size(i)) != i)
+				return false;
+			if(size_to_bucket(bucket_to_size(i) + 1) != i + 1)
+				return false;
+		}
+		return true;
+	}
+
+	static_assert(test_bucket_calculation(num_buckets),
+		"The bucket size calculation seems to be broken");
+
+	static constexpr size_t page_size = [](){
+		if constexpr (is_detected_v<policy_pagesize_t, Policy>)
+			return Policy::pagesize;
+		else
+			return 0x1000;
+	}();
+
+	// Size of the content of a slab.
+	static constexpr size_t slabsize = [](){
+		if constexpr (is_detected_v<policy_slabsize_t, Policy>)
+			return Policy::slabsize;
+		else
+			return 1 << 18;
+	}();
+
+	static_assert(!(slabsize & (page_size - 1)),
+			"Slab content size must be a multiple of the page size");
+
+	// TODO: Refactor the huge frame padding.
+	static constexpr size_t huge_padding = page_size;
+
+	static constexpr bool has_poisoning = is_detected_v<policy_poison_t, Policy>;
+
+	struct freelist {
+		freelist()
+		: link{nullptr} { }
+
+		freelist(const freelist &) = delete;
+
+		freelist &operator= (const freelist &) = delete;
+
+		freelist *link;
+	};
+
+	enum class frame_type {
+		null,
+		slab,
+		large
+	};
+
+	// By frame we mean either a slab_frame or a large memory object.
+	// Frames are stored in a tree to allow fast lookup by in-frame addresses.
+	struct frame {
+		frame(frame_type type_, uintptr_t address_, size_t length_)
+		: type{type_}, address{address_}, length{length_} { }
+
+		frame(const frame &) = delete;
+
+		frame &operator= (const frame &) = delete;
+
+		bool contains(void *p) {
+			auto adr = reinterpret_cast<uintptr_t>(p);
+			return adr >= address && adr < address + length;
+		}
+
+		const frame_type type;
+		const uintptr_t address;
+		const size_t length;
+		rbtree_hook frame_hook;
+	};
+	static_assert(sizeof(frame) <= huge_padding, "Padding too small");
+
+	struct slab_frame : frame {
+		slab_frame(uintptr_t address_, size_t length_, int index_)
+		: frame{frame_type::slab, address_, length_},
+				index{index_}, num_reserved{0}, available{nullptr} { }
+
+		slab_frame(const slab_frame &) = delete;
+
+		slab_frame &operator= (const slab_frame &) = delete;
+
+		const int index;
+		unsigned int num_reserved;
+		freelist *available;
+		rbtree_hook partial_hook;
+	};
+
+	struct frame_less {
+		bool operator() (const frame &a, const frame &b) {
+			return a.address < b.address;
+		}
+	};
+
+	using frame_tree_type = frg::rbtree<
+		frame,
+		&frame::frame_hook,
+		frame_less
+	>;
+
+	using partial_tree_type = frg::rbtree<
+		slab_frame,
+		&slab_frame::partial_hook,
+		frame_less
+	>;
+
+	// Like in jemalloc, we always allocate a slab completely (the head_slb) before
+	// moving to the next slab. This reduces external fragmentation.
+	struct bucket {
+		bucket()
+		: head_slb{nullptr} { }
+
+		Mutex bucket_mutex;
+		slab_frame *head_slb;
+		partial_tree_type partial_tree;
+	};
+
+private:
+	frame *_find_frame(uintptr_t address);
+	slab_frame *_construct_slab(int index);
+	frame *_construct_large(size_t area_size);
+
+	void _verify_integrity();
+	void _verify_frame_integrity(frame *fra);
+
+	void _trace(char c, void *ptr, size_t size);
+private:
+	Policy &_plcy;
+
+	Mutex _tree_mutex;
+	Mutex _trace_mutex;
+	frame_tree_type _frame_tree;
+	size_t _usedPages;
+	bucket _bkts[num_buckets];
+};
+
+// --------------------------------------------------------
+// slab_pool
+// --------------------------------------------------------
+
+template<typename Policy, typename Mutex>
+slab_pool<Policy, Mutex>::slab_pool(Policy &plcy)
+: _plcy{plcy}, _usedPages{0} { }
+
+template<typename Policy, typename Mutex>
+void *slab_pool<Policy, Mutex>::allocate(size_t length) {
+	if(enable_checking)
+		_verify_integrity();
+
+	// malloc() is allowed to either return null or a unique value.
+	// However, some programs always interpret null returns as failure,
+	// so we round up the length.
+	if(!length)
+		length = 1;
+
+	if(length <= max_bucket_size) {
+		int index = size_to_bucket(length);
+		FRG_ASSERT(index <= num_buckets);
+		auto bkt = &_bkts[index];
+
+		unique_lock<Mutex> bucket_guard(bkt->bucket_mutex);
+
+		freelist *object;
+		if(bkt->head_slb) {
+			auto slb = bkt->head_slb;
+
+			object = slb->available;
+			FRG_ASSERT(object);
+			FRG_ASSERT(slb->contains(object));
+			if(object->link && !slb->contains(object->link))
+				FRG_ASSERT(!"slab_pool corruption. Possible write to unallocated object");
+			slb->available = object->link;
+			slb->num_reserved++;
+
+			if(!slb->available) {
+				bkt->partial_tree.remove(slb);
+				bkt->head_slb = bkt->partial_tree.first();
+			}
+		}else{
+			// Call into the Policy without holding locks.
+			bucket_guard.unlock();
+
+			auto slb = _construct_slab(index);
+
+			object = slb->available;
+			FRG_ASSERT(object);
+			FRG_ASSERT(slb->contains(object));
+			if(object->link && !slb->contains(object->link))
+				FRG_ASSERT(!"slab_pool corruption. Possible write to unallocated object");
+			slb->available = object->link;
+			slb->num_reserved++;
+
+			unique_lock<Mutex> tree_guard(_tree_mutex);
+			_frame_tree.insert(slb);
+			_usedPages += (slb->length + huge_padding) / page_size;
+			tree_guard.unlock();
+
+			// Finally, re-lock the bucket to attach the new slab.
+			bucket_guard.lock();
+
+			FRG_ASSERT(slb->available);
+			bkt->partial_tree.insert(slb);
+			if(!bkt->head_slb || slb->address < bkt->head_slb->address)
+				bkt->head_slb = slb;
+		}
+
+		bucket_guard.unlock();
+
+		//if(logAllocations)
+		//	std::cout << "frg/slab: Allocate small-object at " << object << std::endl;
+		object->~freelist();
+		if constexpr (has_poisoning) {
+			_plcy.poison(object, sizeof(freelist));
+			_plcy.unpoison(object, length);
+		}
+		if(enable_checking)
+			_verify_integrity();
+		_trace('a', object, length);
+		return object;
+	}else{
+		auto area_size = (length + page_size - 1) & ~(page_size - 1);
+		auto fra = _construct_large(area_size);
+
+		unique_lock<Mutex> tree_guard(_tree_mutex);
+		_frame_tree.insert(fra);
+		_usedPages += (fra->length + huge_padding) / page_size;
+		tree_guard.unlock();
+
+		//if(logAllocations)
+		//	std::cout << "frg/slab: Allocate large-object at " <<
+		//			(void *)fra->address << std::endl;
+		if(enable_checking)
+			_verify_integrity();
+		_trace('a', reinterpret_cast<void *>(fra->address), length);
+		return reinterpret_cast<void *>(fra->address);
+	}
+}
+
+template<typename Policy, typename Mutex>
+void *slab_pool<Policy, Mutex>::realloc(void *pointer, size_t new_length) {
+	if(enable_checking)
+		_verify_integrity();
+
+	if(!pointer) {
+		return allocate(new_length);
+	}else if(!new_length) {
+		free(pointer);
+		return nullptr;
+	}
+	auto address = reinterpret_cast<uintptr_t>(pointer);
+
+	unique_lock<Mutex> tree_guard(_tree_mutex);
+	auto fra = _find_frame(address);
+	tree_guard.unlock();
+	if(!fra)
+		FRG_ASSERT(!"Pointer is not part of any virtual area");
+
+	if(fra->type == frame_type::slab) {
+		auto slb = static_cast<slab_frame *>(fra);
+		size_t item_size = bucket_to_size(slb->index);
+
+		if(new_length <= item_size) {
+			if constexpr (has_poisoning) {
+				_plcy.unpoison_expand(pointer, item_size);
+				_plcy.poison(pointer, item_size);
+				_plcy.unpoison(pointer, new_length);
+			}
+			return pointer;
+		}
+
+		void *new_pointer = allocate(new_length);
+		if(!new_pointer)
+			return nullptr;
+		memcpy(new_pointer, pointer, item_size);
+		free(pointer);
+		//infoLogger() << "[slab] realloc " << new_pointer << frg::endLog;
+		return new_pointer;
+	}else{
+		FRG_ASSERT(fra->type == frame_type::large);
+		FRG_ASSERT(address == fra->address);
+
+		if(new_length < fra->length)
+			return pointer;
+
+		void *new_pointer = allocate(new_length);
+		if(!new_pointer)
+			return nullptr;
+		memcpy(new_pointer, pointer, fra->length);
+		free(pointer);
+		//infoLogger() << "[slab] realloc " << new_pointer << frg::endLog;
+		return new_pointer;
+	}
+}
+
+template<typename Policy, typename Mutex>
+void slab_pool<Policy, Mutex>::free(void *pointer) {
+	if(enable_checking)
+		_verify_integrity();
+
+	_trace('f', pointer, 0);
+
+	if(!pointer)
+		return;
+
+	//if(logAllocations)
+	//	std::cout << "frg/slab: Free " << pointer << std::endl;
+
+	auto address = reinterpret_cast<uintptr_t>(pointer);
+
+	unique_lock<Mutex> tree_guard(_tree_mutex);
+	auto fra = _find_frame(address);
+	if(!fra)
+		FRG_ASSERT(!"Pointer is not part of any virtual area");
+
+	// First, we handle cases that need to operate with the _tree_mutex held.
+	if(fra->type == frame_type::large) {
+		//if(logAllocations)
+		//	std::cout << "    From area " << fra << std::endl;
+		FRG_ASSERT(address == fra->address);
+//				infoLogger() << "[" << pointer
+//						<< "] Large free from varea " << fra << endLog;
+
+		// Remove the virtual area from the area-list.
+		_frame_tree.remove(fra);
+		_usedPages -= (fra->length + huge_padding) / page_size;
+
+		// Call into the Policy without holding locks.
+		tree_guard.unlock();
+
+		// Note: we cannot access fra->length after poison().
+		auto base = fra->address - huge_padding;
+		auto size = fra->length + huge_padding;
+		if constexpr (has_poisoning)
+			_plcy.poison(reinterpret_cast<void *>(base), size);
+		_plcy.unmap(base, size);
+		if(enable_checking)
+			_verify_integrity();
+		return;
+	}
+
+	// As we deallocate from a slab, we can drop the _tree_mutex now.
+	FRG_ASSERT(fra->type == frame_type::slab);
+	tree_guard.unlock();
+
+	auto slb = static_cast<slab_frame *>(fra);
+	FRG_ASSERT(reinterpret_cast<uintptr_t>(slb) == (address & ~(slabsize - 1)));
+	auto bkt = &_bkts[slb->index];
+
+	size_t item_size = bucket_to_size(slb->index);
+	FRG_ASSERT(!enable_checking || !((address - slb->address) % item_size));
+//				infoLogger() << "[" << pointer
+//						<< "] Small free from varea " << slb << endLog;
+
+	unique_lock<Mutex> bucket_guard(bkt->bucket_mutex);
+
+	bool was_unavailable = !slb->available;
+	FRG_ASSERT(slb->num_reserved);
+
+	if constexpr (has_poisoning) {
+		_plcy.unpoison_expand(pointer, item_size);
+		_plcy.poison(pointer, item_size);
+		_plcy.unpoison(pointer, sizeof(freelist));
+	}
+	auto object = new (pointer) freelist;
+
+	FRG_ASSERT(!slb->available || slb->contains(slb->available));
+	object->link = slb->available;
+	slb->available = object;
+
+	if(was_unavailable) {
+		bkt->partial_tree.insert(slb);
+		if(!bkt->head_slb || slb->address < bkt->head_slb->address)
+			bkt->head_slb = slb;
+	}
+
+	bucket_guard.unlock();
+
+	if(enable_checking)
+		_verify_integrity();
+}
+
+template<typename Policy, typename Mutex>
+void slab_pool<Policy, Mutex>::deallocate(void *pointer, size_t size) {
+	_trace('f', pointer, 0);
+
+	if(!pointer)
+		return;
+
+	//if(logAllocations)
+	//	std::cout << "frg/slab: Free " << pointer << std::endl;
+
+	if(size > max_bucket_size) {
+		this->free(pointer);
+		return;
+	}
+
+	auto address = reinterpret_cast<uintptr_t>(pointer);
+
+	auto slb = reinterpret_cast<slab_frame *>(address & ~(slabsize - 1));
+	FRG_ASSERT(slb->contains(pointer));
+	auto bkt = &_bkts[slb->index];
+
+	size_t item_size = bucket_to_size(slb->index);
+	FRG_ASSERT(!enable_checking || !((address - slb->address) % item_size));
+//				infoLogger() << "[" << pointer
+//						<< "] Small free from varea " << slb << endLog;
+
+	unique_lock<Mutex> bucket_guard(bkt->bucket_mutex);
+
+	bool was_unavailable = !slb->available;
+	FRG_ASSERT(slb->num_reserved);
+
+	if constexpr (has_poisoning) {
+		_plcy.poison(pointer, size);
+		_plcy.unpoison(pointer, sizeof(freelist));
+	}
+	auto object = new (pointer) freelist;
+
+	FRG_ASSERT(!slb->available || slb->contains(slb->available));
+	object->link = slb->available;
+	slb->available = object;
+
+	if(was_unavailable) {
+		bkt->partial_tree.insert(slb);
+		if(!bkt->head_slb || slb->address < bkt->head_slb->address)
+			bkt->head_slb = slb;
+	}
+}
+
+
+template<typename Policy, typename Mutex>
+auto slab_pool<Policy, Mutex>::_find_frame(uintptr_t address)
+-> frame * {
+	auto current = _frame_tree.get_root();
+	while(current) {
+		if(address < current->address) {
+			current = frame_tree_type::get_left(current);
+		}else if(address >= current->address + current->length) {
+			current = frame_tree_type::get_right(current);
+		}else{
+			FRG_ASSERT(address >= current->address
+					&& address < current->address + current->length);
+			return current;
+		}
+	}
+
+	return nullptr;
+}
+
+template<typename Policy, typename Mutex>
+auto slab_pool<Policy, Mutex>::_construct_slab(int index)
+-> slab_frame * {
+//	frg::infoLogger() << "Allocate new area for " << (void *)area_size << frg::endLog;
+
+	// Allocate virtual memory for the slab.
+	uintptr_t address;
+	if constexpr (is_detected_v<policy_map_aligned_t, Policy>) {
+		address = _plcy.map(slabsize, slabsize);
+	} else {
+		address = _plcy.map(2 * slabsize);
+		address = (address + slabsize - 1) & ~(slabsize - 1);
+	}
+
+	auto item_size = bucket_to_size(index);
+	size_t overhead = 0;
+	while(overhead < sizeof(slab_frame)) // FIXME.
+		overhead += item_size;
+	FRG_ASSERT(overhead < slabsize);
+
+	if constexpr (has_poisoning)
+		_plcy.unpoison(reinterpret_cast<void *>(address), sizeof(slab_frame));
+	auto slb = new (reinterpret_cast<void *>(address)) slab_frame(
+			address + overhead, slabsize - overhead, index);
+
+	//if(logAllocations)
+	//	std::cout << "frb/slab: New area at " << area << std::endl;
+
+	// Partition the slab into individual objects.
+	freelist *first = nullptr;
+	for(size_t off = 0; off < slb->length; off += item_size) {
+		if constexpr (has_poisoning)
+			_plcy.unpoison(reinterpret_cast<void *>(slb->address + off), sizeof(freelist));
+		auto object = new (reinterpret_cast<void *>(slb->address + off)) freelist;
+		object->link = first;
+		first = object;
+		//infoLogger() << "[slab] fill " << chunk << frg::endLog;
+	}
+	slb->available = first;
+
+	return slb;
+}
+
+template<typename Policy, typename Mutex>
+auto slab_pool<Policy, Mutex>::_construct_large(size_t area_size)
+-> frame * {
+//	frg::infoLogger() << "Allocate new area for " << (void *)area_size << frg::endLog;
+
+	// Allocate virtual memory for the frame.
+	FRG_ASSERT(!(area_size & (page_size - 1)));
+	uintptr_t address;
+	if constexpr (is_detected_v<policy_map_aligned_t, Policy>) {
+		address = _plcy.map(area_size + huge_padding, page_size);
+	} else {
+		address = _plcy.map(area_size + huge_padding);
+	}
+	if constexpr (has_poisoning)
+		_plcy.unpoison(reinterpret_cast<void *>(address), area_size + huge_padding);
+
+	auto fra = new ((void *)address) frame(frame_type::large,
+			address + huge_padding, area_size);
+
+	//if(logAllocations)
+	//	std::cout << "frb/slab: New area at " << area << std::endl;
+
+	return fra;
+}
+
+template<typename Policy, typename Mutex>
+void slab_pool<Policy, Mutex>::_verify_integrity() {
+	unique_lock<Mutex> tree_guard(_tree_mutex);
+	if(_frame_tree.get_root())
+		_verify_frame_integrity(_frame_tree.get_root());
+}
+
+template<typename Policy, typename Mutex>
+void slab_pool<Policy, Mutex>::_verify_frame_integrity(frame *fra) {
+	if(fra->type == frame_type::slab) {
+		auto slb = static_cast<slab_frame *>(fra);
+		auto bkt = &_bkts[slb->index];
+		unique_lock<Mutex> slab_guard(bkt->bucket_mutex);
+
+		auto object = slb->available;
+		while(object) {
+			FRG_ASSERT(slb->contains(object));
+			object = object->link;
+		}
+	}
+
+	if(_frame_tree.get_left(fra))
+		_verify_frame_integrity(frame_tree_type::get_left(fra));
+	if(_frame_tree.get_right(fra))
+		_verify_frame_integrity(frame_tree_type::get_right(fra));
+}
+
+template<typename Policy, typename Mutex>
+void slab_pool<Policy, Mutex>::_trace(char c, void *ptr, size_t size) {
+	if constexpr (is_detected_v<policy_output_trace_t, Policy>
+			&& is_detected_v<policy_walk_stack_t, Policy>
+			&& is_detected_v<policy_enable_trace_t, Policy>) {
+		if (_plcy.enable_trace()) {
+			unique_lock<Mutex> guard{_trace_mutex};
+
+			_plcy.output_trace(c);
+
+			auto send_value = [this](uintptr_t val) {
+				for (int i = 0; i < 8; i++)
+					_plcy.output_trace((val >> (i * 8)) & 0xFF);
+			};
+
+			send_value(reinterpret_cast<uintptr_t>(ptr));
+			if (c == 'a')
+				send_value(size);
+
+			_plcy.walk_stack([&send_value](uintptr_t val){
+				send_value(val);
+			});
+
+			send_value(0xA5A5A5A5A5A5A5A5);
+		}
+	}
+}
+
+// --------------------------------------------------------
+// slab_allocator
+// --------------------------------------------------------
+
+template<typename Policy, typename Mutex>
+class slab_allocator {
+public:
+	slab_allocator(slab_pool<Policy, Mutex> *pool)
+	: pool_{pool} { }
+
+	void *allocate(size_t size) {
+		return pool_->allocate(size);
+	}
+
+	void deallocate(void *pointer, size_t size) {
+		pool_->deallocate(pointer, size);
+	}
+
+	void free(void *pointer) {
+		pool_->free(pointer);
+	}
+
+	void *reallocate(void *pointer, size_t new_size) {
+		return pool_->realloc(pointer, new_size);
+	}
+
+private:
+	slab_pool<Policy, Mutex> *pool_;
+};
+
+} // namespace frg
diff --git a/mlibc/subprojects/frigg/include/frg/small_vector.hpp b/mlibc/subprojects/frigg/include/frg/small_vector.hpp
new file mode 100644
index 0000000..82866dd
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/small_vector.hpp
@@ -0,0 +1,170 @@
+#ifndef FRG_SMALL_VECTOR_HPP
+#define FRG_SMALL_VECTOR_HPP
+
+#include <utility>
+#include <stdint.h>
+#include <frg/eternal.hpp>
+#include <frg/array.hpp>
+
+namespace frg {
+
+template<typename T, size_t N, typename Allocator>
+class small_vector {
+public:
+	using value_type = T;
+	using reference = value_type&;
+	using iterator = value_type*;
+	using const_iterator = const value_type*;
+
+	friend void swap(small_vector &a, small_vector &b) {
+		using std::swap;
+		swap(a._allocator, b._allocator);
+		swap(a._array, b._array);
+		swap(a._elements, b._elements);
+		swap(a._size, b._size);
+		swap(a._capacity, b._capacity);
+	}
+
+	small_vector(Allocator allocator = Allocator())
+	: _allocator(allocator), _elements(nullptr),
+		_size(0), _capacity(N)
+	{ }
+
+	small_vector(const small_vector &other)
+	: small_vector(other._allocator) {
+		auto other_size = other.size();
+		_ensure_capacity(other_size);
+		auto container = _get_container();
+		for (int i = 0; i < other_size; i++)
+			new (&container[i]) T(other[i]);
+		_size = other_size;
+	}
+
+	small_vector(small_vector &&other)
+	: small_vector(other._allocator) {
+		swap(*this, other);
+	}
+
+	size_t size() const {
+		return _size;
+	}
+
+	bool empty() const {
+		return _size == 0;
+	}
+
+	value_type &push_back(const T &element) {
+		_ensure_capacity(_size + 1);
+		auto container = _get_container();
+		T *pointer = new (&container[_size]) T(element);
+		_size++;
+		return *pointer;
+	}
+	value_type &push_back(T &&element) {
+		_ensure_capacity(_size + 1);
+		auto container = _get_container();
+		T *pointer = new (&container[_size]) T(std::move(element));
+		_size++;
+		return *pointer;
+	}
+
+	template<typename... Args>
+	value_type &emplace_back(Args&&... args) {
+		_ensure_capacity(_size + 1);
+		auto container = _get_container();
+		T *pointer = new (&container[_size]) T(std::forward<Args>(args)...);
+		_size++;
+		return *pointer;
+	}
+
+	template<typename... Args>
+	void resize(size_t new_size, Args&&... args) {
+		_ensure_capacity(new_size);
+		auto container = _get_container();
+		if (new_size < _size) {
+			for (size_t i = new_size; i < _size; i++)
+				container[i].~T();
+		} else {
+			for (size_t i = _size; i < new_size; i++)
+				new (&container[i]) T(std::forward<Args>(args)...);
+		}
+		_size = new_size;
+	}
+
+	T *data() {
+		return _get_container();
+	}
+	const T *data() const {
+		return _get_container();
+	}
+
+	iterator begin() {
+		return _get_container();
+	}
+	const_iterator begin() const {
+		return _get_container();
+	}
+
+	iterator end() {
+		return _get_container() + _size;
+	}
+	const_iterator end() const {
+		return _get_container() + _size;
+	}
+
+	value_type &operator[] (size_t index) {
+		auto container = _get_container();
+		return container[index];
+	}
+	const value_type &operator[] (size_t index) const {
+		auto container = _get_container();
+		return container[index];
+	}
+private:
+	bool _is_small() const {
+		return _capacity <= N;
+	}
+
+	void _ensure_capacity(size_t capacity) {
+		if (capacity <= _capacity)
+			return;
+
+		auto container = _get_container();		
+		size_t new_capacity = capacity * 2;
+		T *new_array = (T *)_allocator.allocate(sizeof(T) * new_capacity);
+		for(size_t i = 0; i < _capacity; i++)
+			new (&new_array[i]) T(std::move(container[i]));
+
+		for(size_t i = 0; i < _size; i++)
+			container[i].~T();
+		// if the container is the array then _elements is a nullptr
+		// and this is an no-op
+		_allocator.free(_elements);
+		
+		_elements = new_array;
+		_capacity = new_capacity;
+	}
+
+	value_type *_get_container() {
+		if (_is_small())
+			return reinterpret_cast<value_type*>(&_array[0].buffer);
+		else
+			return _elements;
+	}
+	const value_type *_get_container() const {
+		if (_is_small())
+			return reinterpret_cast<const value_type*>(&_array[0].buffer);
+		else
+			return _elements;
+	}
+
+	Allocator _allocator;
+	array<aligned_storage<sizeof(T), alignof(T)>, N> _array;
+	T *_elements;
+	size_t _size;
+	size_t _capacity;
+};
+
+} // namespace frg
+
+#endif // FRG_SMALL_VECTOR_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/span.hpp b/mlibc/subprojects/frigg/include/frg/span.hpp
new file mode 100644
index 0000000..6821de4
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/span.hpp
@@ -0,0 +1,27 @@
+#pragma once
+
+#include <stddef.h>
+
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename T>
+struct span {
+	span(T *p, size_t n)
+	: p_{p}, n_{n} { }
+
+	T *data() const {
+		return p_;
+	}
+
+	size_t size() const {
+		return n_;
+	}
+
+private:
+	T *p_;
+	size_t n_;
+};
+
+} // namespace frg
diff --git a/mlibc/subprojects/frigg/include/frg/spinlock.hpp b/mlibc/subprojects/frigg/include/frg/spinlock.hpp
new file mode 100644
index 0000000..20b1e2e
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/spinlock.hpp
@@ -0,0 +1,30 @@
+#pragma once
+
+#include <stdint.h>
+
+namespace frg {
+
+struct ticket_spinlock {
+	constexpr ticket_spinlock()
+	: next_ticket_{0}, serving_ticket_{0} { }
+
+	ticket_spinlock(const ticket_spinlock &) = delete;
+	ticket_spinlock &operator= (const ticket_spinlock &) = delete;
+
+	void lock() {
+		auto ticket = __atomic_fetch_add(&next_ticket_, 1, __ATOMIC_RELAXED);
+		while(__atomic_load_n(&serving_ticket_, __ATOMIC_ACQUIRE) != ticket)
+			;
+	}
+
+	void unlock() {
+		auto current = __atomic_load_n(&serving_ticket_, __ATOMIC_RELAXED);
+		__atomic_store_n(&serving_ticket_, current + 1, __ATOMIC_RELEASE);
+	}
+
+private:
+	uint32_t next_ticket_;
+	uint32_t serving_ticket_;
+};
+
+} // namespace frg
diff --git a/mlibc/subprojects/frigg/include/frg/stack.hpp b/mlibc/subprojects/frigg/include/frg/stack.hpp
new file mode 100644
index 0000000..1418ade
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/stack.hpp
@@ -0,0 +1,44 @@
+#ifndef FRG_STACK_HPP
+#define FRG_STACK_HPP
+
+#include <frg/macros.hpp>
+#include <frg/vector.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename T, typename Allocator, typename Container =
+	frg::vector<T, Allocator>>
+class stack {
+public:
+	using value_type = typename Container::value_type;
+	using reference = typename Container::reference;
+
+	stack() { }
+	stack(Allocator alloc) : _container(alloc) { }
+
+	reference top() {
+		return _container.back();
+	}
+
+	void pop() {
+		_container.pop();
+	}
+
+	void push(const value_type &value) {
+		_container.push_back(value);
+	}
+
+	size_t size() const {
+		return _container.size();
+	}
+
+	bool empty() const {
+		return _container.empty();
+	}
+private:
+	Container _container;
+};
+
+} // namespace frg
+
+#endif
diff --git a/mlibc/subprojects/frigg/include/frg/std_compat.hpp b/mlibc/subprojects/frigg/include/frg/std_compat.hpp
new file mode 100644
index 0000000..bcd6203
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/std_compat.hpp
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace frg {
+
+struct stl_allocator {
+	void *allocate(size_t size) {
+		return operator new(size);
+	}
+
+	void free(void *ptr) {
+		operator delete(ptr);
+	}
+};
+
+} // namespace frg
diff --git a/mlibc/subprojects/frigg/include/frg/string.hpp b/mlibc/subprojects/frigg/include/frg/string.hpp
new file mode 100644
index 0000000..eb6750c
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/string.hpp
@@ -0,0 +1,364 @@
+#ifndef FRG_STRING_HPP
+#define FRG_STRING_HPP
+
+#include <string.h>
+
+#include <frg/hash.hpp>
+#include <frg/macros.hpp>
+#include <frg/optional.hpp>
+#include <frg/utility.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename Char>
+class basic_string_view {
+public:
+	typedef Char CharType;
+
+	basic_string_view()
+	: _pointer{nullptr}, _length{0} { }
+
+	basic_string_view(const Char *cs)
+	: _pointer{cs}, _length{0} {
+		// We cannot call strlen() as Char might not be the usual char.
+		while(cs[_length])
+			_length++;
+	}
+
+	basic_string_view(const Char *s, size_t length)
+	: _pointer{s}, _length{length} { }
+
+	const Char *data() const {
+		return _pointer;
+	}
+
+	const Char &operator[] (size_t index) const {
+		return _pointer[index];
+	}
+
+	size_t size() const {
+		return _length;
+	}
+
+	bool operator== (basic_string_view other) const {
+		if(_length != other._length)
+			return false;
+		for(size_t i = 0; i < _length; i++)
+			if(_pointer[i] != other._pointer[i])
+				return false;
+		return true;
+	}
+	bool operator!= (basic_string_view other) const {
+		return !(*this == other);
+	}
+
+	size_t find_first(Char c, size_t start_from = 0) {
+		for(size_t i = start_from; i < _length; i++)
+			if(_pointer[i] == c)
+				return i;
+
+		return size_t(-1);
+	}
+
+	size_t find_last(Char c) {
+		for(size_t i = _length; i > 0; i--)
+			if(_pointer[i - 1] == c)
+				return i - 1;
+
+		return size_t(-1);
+	}
+
+	basic_string_view sub_string(size_t from, size_t size) {
+		FRG_ASSERT(from + size <= _length);
+		return basic_string_view(_pointer + from, size);
+	}
+
+	template<typename T>
+	optional<T> to_number() {
+		T value = 0;
+		for(size_t i = 0; i < _length; i++) {
+			if(!(_pointer[i] >= '0' && _pointer[i] <= '9'))
+				return null_opt;
+			value = value * 10 + (_pointer[i] - '0');
+		}
+		return value;
+	}
+
+private:
+	const Char *_pointer;
+	size_t _length;
+};
+
+typedef basic_string_view<char> string_view;
+
+template<typename Char, typename Allocator>
+class basic_string {
+public:
+	typedef Char CharType;
+
+	friend void swap(basic_string &a, basic_string &b) {
+		using std::swap;
+		swap(a._allocator, b._allocator);
+		swap(a._buffer, b._buffer);
+		swap(a._length, b._length);
+	}
+
+	basic_string(Allocator allocator = Allocator())
+	: _allocator{std::move(allocator)}, _buffer{nullptr}, _length{0} { }
+
+	basic_string(const Char *c_string, Allocator allocator = Allocator())
+	: _allocator{std::move(allocator)} {
+		_length = strlen(c_string);
+		_buffer = (Char *)_allocator.allocate(sizeof(Char) * _length + 1);
+		memcpy(_buffer, c_string, sizeof(Char) * _length);
+		_buffer[_length] = 0;
+	}
+
+	// Compatibility/transition constructor.
+	basic_string(Allocator allocator, const Char *c_string)
+	: basic_string{c_string, std::move(allocator)} { }
+
+	basic_string(const Char *buffer, size_t size, Allocator allocator = Allocator())
+	: _allocator{std::move(allocator)}, _length{size} {
+		_buffer = (Char *)_allocator.allocate(sizeof(Char) * _length + 1);
+		memcpy(_buffer, buffer, sizeof(Char) * _length);
+		_buffer[_length] = 0;
+	}
+
+	// Compatibility/transition constructor.
+	basic_string(Allocator allocator, const Char *buffer, size_t size)
+	: basic_string{buffer, size, std::move(allocator)} { }
+
+	basic_string(const basic_string_view<Char> &view, Allocator allocator = Allocator())
+	: _allocator{std::move(allocator)}, _length{view.size()} {
+		_buffer = (Char *)_allocator.allocate(sizeof(Char) * _length + 1);
+		memcpy(_buffer, view.data(), sizeof(Char) * _length + 1);
+		_buffer[_length] = 0;
+	}
+
+	// Compatibility/transition constructor.
+	basic_string(Allocator allocator, const basic_string_view<Char> &view)
+	: basic_string{view, std::move(allocator)} { }
+
+	basic_string(size_t size, Char c = 0, Allocator allocator = Allocator())
+	: _allocator{std::move(allocator)}, _length{size} {
+		_buffer = (Char *)_allocator.allocate(sizeof(Char) * _length + 1);
+		for(size_t i = 0; i < size; i++)
+			_buffer[i] = c;
+		_buffer[_length] = 0;
+	}
+
+	basic_string(const basic_string &other)
+	: _allocator{other._allocator}, _length{other._length} {
+		_buffer = (Char *)_allocator.allocate(sizeof(Char) * _length + 1);
+		memcpy(_buffer, other._buffer, sizeof(Char) * _length);
+		_buffer[_length] = 0;
+	}
+
+	~basic_string() {
+		if(_buffer)
+			_allocator.free(_buffer);
+	}
+
+	basic_string &operator= (basic_string other) {
+		swap(*this, other);
+		return *this;
+	}
+
+	void resize(size_t new_length) {
+		size_t copy_length = _length;
+		if(copy_length > new_length)
+			copy_length = new_length;
+
+		Char *new_buffer = (Char *)_allocator.allocate(sizeof(Char) * new_length + 1);
+		memcpy(new_buffer, _buffer, sizeof(Char) * copy_length);
+		new_buffer[new_length] = 0;
+
+		if(_buffer)
+			_allocator.free(_buffer);
+		_length = new_length;
+		_buffer = new_buffer;
+	}
+
+	// TODO: Inefficient. Does two copies (one here, one in constructor).
+	// TODO: Better: Return expression template?
+	basic_string operator+ (const basic_string_view<Char> &other) {
+		size_t new_length = _length + other.size();
+		Char *new_buffer = (Char *)_allocator.allocate(sizeof(Char) * new_length + 1);
+		memcpy(new_buffer, _buffer, sizeof(Char) * _length);
+		memcpy(new_buffer + _length, other.data(), sizeof(Char) * other.size());
+		new_buffer[new_length] = 0;
+
+		return basic_string(_allocator, new_buffer, new_length);
+	}
+
+	// TODO: Inefficient. Does two copies (one here, one in constructor).
+	// TODO: Better: Return expression template?
+	basic_string operator+ (Char c) {
+		size_t new_length = _length + 1;
+		Char *new_buffer = (Char *)_allocator.allocate(sizeof(Char) * new_length + 1);
+		memcpy(new_buffer, _buffer, sizeof(Char) * _length);
+		new_buffer[_length] = c;
+		new_buffer[new_length] = 0;
+
+		return basic_string(_allocator, new_buffer, new_length);
+	}
+
+	basic_string &operator+= (const basic_string_view<Char> &other) {
+		size_t new_length = _length + other.size();
+		Char *new_buffer = (Char *)_allocator.allocate(sizeof(Char) * new_length + 1);
+		memcpy(new_buffer, _buffer, sizeof(Char) * _length);
+		memcpy(new_buffer + _length, other.data(), sizeof(Char) * other.size());
+		new_buffer[new_length] = 0;
+
+		if(_buffer)
+			_allocator.free(_buffer);
+		_length = new_length;
+		_buffer = new_buffer;
+
+		return *this;
+	}
+
+	basic_string &operator+= (Char c) {
+		/* TODO: SUPER INEFFICIENT should be done with a _capacity variable */
+		Char *new_buffer = (Char *)_allocator.allocate(sizeof(Char) * _length + 2);
+		memcpy(new_buffer, _buffer, sizeof(Char) * _length);
+		new_buffer[_length] = c;
+		new_buffer[_length + 1] = 0;
+
+		if (_buffer)
+			_allocator.free(_buffer);
+		_length++;
+		_buffer = new_buffer;
+
+		return *this;
+	}
+
+	// used to disable deallocation upon object destruction
+	void detach() {
+		_buffer = nullptr;
+		_length = 0;
+	}
+
+	Char *data() {
+		return _buffer;
+	}
+	const Char *data() const {
+		return _buffer;
+	}
+
+	Char &operator[] (size_t index) {
+		return _buffer[index];
+	}
+	const Char &operator[] (size_t index) const {
+		return _buffer[index];
+	}
+
+	size_t size() const {
+		return _length;
+	}
+
+	bool operator== (const basic_string_view<Char> &other) const {
+		if(_length != other.size())
+			return false;
+		for(size_t i = 0; i < _length; i++)
+			if(_buffer[i] != other[i])
+				return false;
+		return true;
+	}
+
+	bool operator!= (const basic_string_view<Char> &other) const {
+		return !(*this == other);
+	}
+
+	operator basic_string_view<Char> () const {
+		return basic_string_view<Char>(_buffer, _length);
+	}
+
+private:
+	Allocator _allocator;
+	Char *_buffer;
+	size_t _length;
+};
+
+template<typename Allocator>
+using string = basic_string<char, Allocator>;
+
+template<typename Char>
+class hash<basic_string_view<Char>> {
+public:
+	unsigned int operator() (const basic_string_view<Char> &string) const {
+		unsigned int hash = 0;
+		for(size_t i = 0; i < string.size(); i++)
+			hash += 31 * hash + string[i];
+		return hash;
+	}
+};
+
+template<typename Char, typename Allocator>
+class hash<basic_string<Char, Allocator>> {
+public:
+	unsigned int operator() (const basic_string<Char, Allocator> &string) const {
+		unsigned int hash = 0;
+		for(size_t i = 0; i < string.size(); i++)
+			hash += 31 * hash + string[i];
+		return hash;
+	}
+};
+
+namespace _to_string_impl {
+	template<typename T>
+	constexpr size_t num_digits(T v, int radix) {
+		size_t n = 0;
+		while(v) {
+			v /= radix;
+			n++;
+		}
+		return n;
+	}
+
+	template<typename T>
+	constexpr size_t num_digits(int radix) {
+		return 33;
+		//TODO: This is actually something like: max(num_digits(std::numeric_limits<T>::max(), radix),
+		//		num_digits(std::numeric_limits<T>::min(), radix) + 1);
+	}
+
+	template<typename T>
+	constexpr size_t num_digits() {
+		return num_digits<T>(2);
+	}
+
+	constexpr auto small_digits = "0123456789abcdef";
+
+	template<typename T, typename Pool>
+	string<Pool> to_allocated_string(Pool &pool, T v, int radix = 10, size_t precision = 1,
+			const char *digits = small_digits) {
+		constexpr auto m = num_digits<T>();
+		FRG_ASSERT(v >= 0);
+
+		char buffer[m];
+		size_t n = 0;
+		while(v) {
+			FRG_ASSERT(n < m);
+			buffer[n++] = digits[v % radix];
+			v /= radix;
+		}
+
+		string<Pool> result(pool);
+		auto len = max(precision, n);
+		result.resize(max(precision, n));
+
+		for(size_t i = 0; i < len - n; i++)
+			result[i] = '0';
+		for(size_t i = 0; i < n; i++)
+			result[len - n + i] = buffer[n - (i + 1)];
+		return result;
+	}
+}
+
+using _to_string_impl::to_allocated_string;
+
+} // namespace frg
+
+#endif // FRG_STRING_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/tuple.hpp b/mlibc/subprojects/frigg/include/frg/tuple.hpp
new file mode 100644
index 0000000..be24af1
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/tuple.hpp
@@ -0,0 +1,271 @@
+#ifndef FRG_TUPLE_HPP
+#define FRG_TUPLE_HPP
+
+#include <stddef.h>
+#include <tuple>
+#include <utility>
+#include <type_traits>
+
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+namespace _tuple {
+	template<typename... Types>
+	struct storage;
+
+	template<typename T, typename... Types>
+	struct storage<T, Types...> {
+		storage() = default;
+
+		storage(T item, Types... tail)
+		: item(std::move(item)), tail(std::move(tail)...) { }
+
+		template<typename... UTypes>
+		storage(const storage<UTypes...> &other)
+		: item(other.item), tail(other.tail) { }
+
+		template<typename... UTypes>
+		storage(storage<UTypes...> &&other)
+		: item(std::move(other.item)), tail(std::move(other.tail)) { }
+
+		T item;
+		storage<Types...> tail;
+	};
+
+	template<>
+	struct storage<> {
+
+	};
+
+	template<int n, typename... Types>
+	struct nth_type;
+
+	template<int n, typename T, typename... Types>
+	struct nth_type<n, T, Types...> {
+		typedef typename nth_type<n - 1, Types...>::type  type;
+	};
+
+	template<typename T, typename... Types>
+	struct nth_type<0, T, Types...> {
+		typedef T type;
+	};
+
+	template<int n, typename... Types>
+	struct access_helper;
+
+	template<int n, typename T, typename... Types>
+	struct access_helper<n, T, Types...> {
+		static typename nth_type<n - 1, Types...>::type &access(storage<T, Types...> &stor) {
+			return access_helper<n - 1, Types...>::access(stor.tail);
+		}
+		static const typename nth_type<n - 1, Types...>::type &access(
+				const storage<T, Types...> &stor) {
+			return access_helper<n - 1, Types...>::access(stor.tail);
+		}
+	};
+
+	template<typename T, typename... Types>
+	struct access_helper<0, T, Types...> {
+		static T &access(storage<T, Types...> &stor) {
+			return stor.item;
+		}
+		static const T &access(const storage<T, Types...> &stor) {
+			return stor.item;
+		}
+	};
+
+} // namespace _tuple
+
+template<typename... Types>
+class tuple {
+public:
+	tuple() = default;
+
+	tuple(Types... args)
+	: _stor(std::move(args)...) { }
+
+	template<typename... UTypes>
+	friend class tuple;
+
+	template<size_t n, typename... UTypes>
+	struct _tuple_is_constructible {
+		static constexpr bool value = std::is_constructible<typename _tuple::nth_type<n,
+				 Types...>::type, typename _tuple::nth_type<n, UTypes...>::type>::
+					 value && _tuple_is_constructible<n - 1,
+				 UTypes...>::value;
+	};
+
+	template<typename... UTypes>
+	struct _tuple_is_constructible<0, UTypes...> {
+		static constexpr bool value = std::is_constructible<typename _tuple::nth_type<0,
+				 Types...>::type, typename _tuple::nth_type<0, UTypes...>::type>::
+					 value;
+	};
+
+	template<typename... UTypes,
+		typename = std::enable_if_t<_tuple_is_constructible<
+			sizeof...(UTypes) - 1, const UTypes &...>::value>>
+	tuple(const tuple<UTypes...> &other) : _stor(other._stor) { }
+
+	template<typename... UTypes,
+		typename = std::enable_if_t<_tuple_is_constructible<
+			sizeof...(UTypes) - 1, UTypes &&...>::value>>
+	tuple(tuple<UTypes...> &&other) : _stor(std::move(other._stor)) { }
+
+	template<int n>
+	typename _tuple::nth_type<n, Types...>::type &get() {
+		return _tuple::access_helper<n, Types...>::access(_stor);
+	}
+	template<int n>
+	const typename _tuple::nth_type<n, Types...>::type &get() const {
+		return _tuple::access_helper<n, Types...>::access(_stor);
+	}
+
+private:
+	_tuple::storage<Types...> _stor;
+};
+
+// Specialization to allow empty tuples.
+template<>
+class tuple<> { };
+
+template<typename... Types>
+tuple<typename std::remove_reference_t<Types>...> make_tuple(Types &&... args) {
+	return tuple<typename std::remove_reference_t<Types>...>(std::forward<Types>(args)...);
+}
+
+namespace _tuple {
+	template<typename F, typename... Args, size_t... I>
+	auto apply(F functor, const tuple<Args...> &args, std::index_sequence<I...>) {
+		return functor(args.template get<I>()...);
+	}
+
+	template<typename F, typename... Args, size_t... I>
+	auto apply(F functor, tuple<Args...> &&args, std::index_sequence<I...>) {
+		return functor(std::move(args.template get<I>())...);
+	}
+
+	// Turns a set of tuple-like types into a tuple
+	template<size_t, typename, typename, size_t>
+	struct make_tuple_impl;
+
+	template<size_t idx, typename Tuple, typename... Types, size_t size>
+	struct make_tuple_impl<idx, tuple<Types...>, Tuple, size> :
+	make_tuple_impl<idx + 1, tuple<Types..., typename std::tuple_element<idx, Tuple>::type>,
+	Tuple, size>
+	{};
+
+	template<size_t size, typename Tuple, typename... Types>
+	struct make_tuple_impl<size, tuple<Types...>, Tuple, size> {
+		using type = tuple<Types...>;
+	};
+
+	// Helper struct to turn a tuple-like T into a tuple<T>
+	template<typename T>
+	struct do_make_tuple
+	: public make_tuple_impl<0, tuple<>, std::remove_reference_t<T>, std::tuple_size<
+	std::remove_reference_t<T>>::value>
+	{};
+
+	// Computes the return type of a tuple_cat call
+	template<typename...>
+	struct tuple_combiner;
+
+	template<>
+	struct tuple_combiner<> {
+		using type = tuple<>;
+	};
+
+	template<typename... Ts>
+	struct tuple_combiner<tuple<Ts...>> {
+		using type = tuple<Ts...>;
+	};
+
+	template<typename... T1, typename... T2, typename... Remainder>
+	struct tuple_combiner<tuple<T1...>, tuple<T2...>, Remainder...> {
+		using type = typename tuple_combiner<tuple<T1..., T2...>, Remainder...>::type;
+	};
+
+	// Computes the return type of a tuple_cat call taking
+	// a pack of tuple-like types
+	template<typename... Tuples>
+	struct tuple_cat_result {
+		typedef typename tuple_combiner<
+			typename do_make_tuple<Tuples>::type...>::type type;
+	};
+
+	// Builds an std::integer_sequence of the tuple_size of the
+	// first tuple passed to the template pack
+	template<typename...>
+	struct make_indices_from_1st;
+
+	template<>
+	struct make_indices_from_1st<> {
+		typedef typename std::make_index_sequence<0> type;
+	};
+
+	template<typename Tuple, typename... Tuples>
+	struct make_indices_from_1st<Tuple, Tuples...> {
+		typedef typename std::make_index_sequence<std::tuple_size<
+			typename std::remove_reference<Tuple>::type>::value> type;
+	};
+
+	// Performs the actual concatenation for tuple_cat
+	template<typename Ret, typename Indices, typename... Tuples>
+	struct tuple_concater;
+
+	template<typename Ret, size_t... Indices, typename Tuple, typename... Tuples>
+	struct tuple_concater<Ret, std::index_sequence<Indices...>, Tuple, Tuples...> {
+		template<typename... Res>
+		static constexpr Ret do_concat(Tuple&& tp, Tuples&&... tps, Res&&... res) {
+			typedef typename make_indices_from_1st<Tuples...>::type index;
+			typedef tuple_concater<Ret, index, Tuples...> next;
+			return next::do_concat(std::forward<Tuples>(tps)...,
+					std::forward<Res>(res)...,
+					std::move(tp.template get<Indices>())...);
+		}
+	};
+
+	template<typename Ret>
+	struct tuple_concater<Ret, std::index_sequence<>> {
+		template <typename... Res>
+		static constexpr Ret do_concat(Res&&... res) {
+			return Ret(std::forward<Res>(res)...);
+		}
+	};
+} // namespace tuple
+
+template<typename F, typename... Args>
+auto apply(F functor, const tuple<Args...> &args) {
+	return _tuple::apply(std::move(functor), args, std::index_sequence_for<Args...>());
+}
+
+template<typename F, typename... Args>
+auto apply(F functor, tuple<Args...> &&args) {
+	return _tuple::apply(std::move(functor), std::move(args), std::index_sequence_for<Args...>());
+}
+
+template <typename... Tuples,
+	 typename Ret = typename _tuple::tuple_cat_result<Tuples...>::type>
+Ret tuple_cat(Tuples&&... args) {
+	typedef typename _tuple::make_indices_from_1st<Tuples...>::type index;
+	typedef _tuple::tuple_concater<Ret, index, Tuples...> concater;
+	return concater::do_concat(std::forward<Tuples>(args)...);
+}
+
+} // namespace frg
+
+namespace std {
+	template<typename... Types>
+	struct tuple_size<frg::tuple<Types...>> {
+		static constexpr size_t value = sizeof...(Types);
+	};
+
+	template<size_t I, typename... Types>
+	struct tuple_element<I, frg::tuple<Types...>> {
+		using type = typename frg::_tuple::nth_type<I, Types...>::type;
+	};
+}
+
+#endif // FRG_TUPLE_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/unique.hpp b/mlibc/subprojects/frigg/include/frg/unique.hpp
new file mode 100644
index 0000000..ed7d007
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/unique.hpp
@@ -0,0 +1,84 @@
+#ifndef FRG_UNIQUE_HPP
+#define FRG_UNIQUE_HPP
+
+#include <utility>
+
+namespace frg {
+
+template <typename T, typename Allocator>
+struct unique_ptr {
+	friend void swap(unique_ptr &a, unique_ptr &b) {
+		using std::swap;
+		swap(a._ptr, b._ptr);
+		swap(a._allocator, b._allocator);
+	}
+
+	unique_ptr(Allocator allocator)
+	:_ptr{nullptr}, _allocator(std::move(allocator)) {}
+
+	unique_ptr(Allocator allocator, T *ptr)
+	:_ptr{ptr}, _allocator(std::move(allocator)) {}
+
+	~unique_ptr() {
+		if (_ptr)
+			_allocator.free(_ptr);
+	}
+
+	unique_ptr(const unique_ptr &) = delete;
+	unique_ptr &operator=(const unique_ptr &) = delete;
+
+	unique_ptr(unique_ptr &&p) {
+		swap(*this, p);
+	}
+
+	unique_ptr &operator=(unique_ptr &&p) {
+		swap(*this, p);
+		return *this;
+	}
+
+	T *get() {
+		return _ptr;
+	}
+
+	T &operator*() {
+		return *_ptr;
+	}
+
+	T *operator->() {
+		return _ptr;
+	}
+
+	T *release() {
+		T *old = _ptr;
+		_ptr = nullptr;
+
+		return old;
+	}
+
+	operator bool() {
+		return _ptr;
+	}
+
+	void reset(T *ptr) {
+		T *old = _ptr;
+		_ptr = ptr;
+
+		if (old)
+			_allocator.free(old);
+	}
+
+private:
+	T *_ptr;
+	Allocator _allocator;
+};
+
+template <typename T, typename Allocator, typename ...Args>
+unique_ptr<T, Allocator> make_unique(Allocator allocator, Args &&...args) {
+	T *ptr = new (allocator.allocate(sizeof(T))) T{
+			std::forward<Args>(args)...};
+	return unique_ptr<T, Allocator>{std::move(allocator), ptr};
+}
+
+}
+
+#endif //FRG_UNIQUE_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/utility.hpp b/mlibc/subprojects/frigg/include/frg/utility.hpp
new file mode 100644
index 0000000..8003d19
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/utility.hpp
@@ -0,0 +1,32 @@
+#ifndef FRG_UTILITY_HPP
+#define FRG_UTILITY_HPP
+
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename T>
+const T &min(const T &a, const T &b) {
+	return (b < a) ? b : a;
+}
+
+template<typename T>
+const T &max(const T &a, const T &b) {
+	return (a < b) ? b : a;
+}
+
+template<typename Tag, typename T>
+struct composition : private T {
+	static T &get(composition<Tag, T> *p) {
+		return *static_cast<T *>(p);
+	}
+};
+
+template<typename Tag, typename T>
+T &get(composition<Tag, T> *p) {
+	return composition<Tag, T>::get(p);
+}
+
+} // namespace frg
+
+#endif // FRG_UTILITY_HPP
diff --git a/mlibc/subprojects/frigg/include/frg/variant.hpp b/mlibc/subprojects/frigg/include/frg/variant.hpp
new file mode 100644
index 0000000..b9c5f5d
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/variant.hpp
@@ -0,0 +1,250 @@
+#pragma once
+
+#include <frg/eternal.hpp>
+#include <frg/macros.hpp>
+#include <type_traits>
+#include <stddef.h>
+
+namespace frg {
+
+namespace _variant {
+	// check if S is one of the types T
+	template<typename S, typename... T>
+	struct exists : public std::false_type { };
+
+	template<typename S, typename... T>
+	struct exists<S, S, T...> : public std::true_type { };
+
+	template<typename S, typename H, typename... T>
+	struct exists<S, H, T...> : public exists<S, T...> { };
+
+	// get the index of S in the argument pack T
+	template<typename, typename S, typename... T>
+	struct index_of_helper { };
+
+	template<typename S, typename... T>
+	struct index_of_helper<std::enable_if_t<exists<S, S, T...>::value>, S, S, T...>
+	: public std::integral_constant<size_t, 0> { };
+
+	template<typename S, typename H, typename... T>
+	struct index_of_helper<std::enable_if_t<exists<S, H, T...>::value>, S, H, T...>
+	: public std::integral_constant<size_t, index_of_helper<void, S, T...>::value + 1> { };
+
+	template<typename S, typename... T>
+	using index_of = index_of_helper<void, S, T...>;
+
+	// get a type with a certain index from the argument pack T
+	template<size_t Index, typename... T>
+	struct get_helper { };
+
+	template<typename H, typename... T>
+	struct get_helper<0, H, T...> {
+		using type = H;
+	};
+
+	template<size_t Index, typename H, typename... T>
+	struct get_helper<Index, H, T...>
+	: public get_helper<Index - 1, T...> { };
+
+	template<size_t Index, typename... T>
+	using get = typename get_helper<Index, T...>::type;
+};
+
+template<typename... T>
+struct variant {
+	static constexpr size_t invalid_tag = size_t(-1);
+
+	template<typename X, size_t Index = _variant::index_of<X, T...>::value>
+	static constexpr size_t tag_of() {
+		return Index;
+	}
+
+	variant() : tag_{invalid_tag} { }
+
+	template<typename X, size_t Index = _variant::index_of<X, T...>::value>
+	variant(X object) : variant() {
+		construct_<Index>(std::move(object));
+	};
+
+	variant(const variant &other) : variant() {
+		if(other)
+			copy_construct_<0>(other);
+	}
+
+	variant(variant &&other) : variant() {
+		if(other)
+			move_construct_<0>(std::move(other));
+	}
+
+	~variant() {
+		if(*this)
+			destruct_<0>();
+	}
+
+	explicit operator bool() const {
+		return tag_ != invalid_tag;
+	}
+
+	variant &operator= (variant other) {
+		// Because swap is quite hard to implement for this type we don't use copy-and-swap.
+		// Instead we perform a destruct-then-move-construct operation on the internal object.
+		// Note that we take the argument by value so there are no self-assignment problems.
+		if(tag_ == other.tag_) {
+			assign_<0>(std::move(other));
+		} else {
+			if(*this)
+				destruct_<0>();
+			if(other)
+				move_construct_<0>(std::move(other));
+		}
+		return *this;
+	}
+
+	size_t tag() {
+		return tag_;
+	}
+
+	template<typename X, size_t Index = _variant::index_of<X, T...>::value>
+	bool is() const {
+		return tag_ == Index;
+	}
+
+	template<typename X, size_t Index = _variant::index_of<X, T...>::value>
+	X &get() {
+		FRG_ASSERT(tag_ == Index);
+		return *std::launder(reinterpret_cast<X *>(access_()));
+	}
+	template<typename X, size_t Index = _variant::index_of<X, T...>::value>
+	const X &get() const {
+		FRG_ASSERT(tag_ == Index);
+		return *std::launder(reinterpret_cast<const X *>(access_()));
+	}
+
+	template<typename X, size_t Index = _variant::index_of<X, T...>::value,
+			typename... Args>
+	void emplace(Args &&... args) {
+		if(tag_ != invalid_tag)
+			destruct_<0>();
+		new (access_()) X(std::forward<Args>(args)...);
+		tag_ = Index;
+	}
+
+	template<typename F>
+	std::common_type_t<std::invoke_result_t<F, T&>...> apply(F functor) {
+		return apply_<F, 0>(std::move(functor));
+	}
+
+	template<typename F>
+	std::common_type_t<std::invoke_result_t<F, const T&>...> const_apply(F functor) const {
+		return apply_<F, 0>(std::move(functor));
+	}
+
+private:
+	void *access_() {
+		return storage_.buffer;
+	}
+	const void *access_() const {
+		return storage_.buffer;
+	}
+
+	// construct the internal object from one of the summed types
+	template<size_t Index, typename X = _variant::get<Index, T...>>
+	void construct_(X object) {
+		FRG_ASSERT(!*this);
+		new (access_()) X(std::move(object));
+		tag_ = Index;
+	}
+
+	// construct the internal object by copying from another variant
+	template<size_t Index> requires (Index < sizeof...(T))
+	void copy_construct_(const variant &other) {
+		using value_type = _variant::get<Index, T...>;
+		if(other.tag_ == Index) {
+			FRG_ASSERT(!*this);
+			new (access_()) value_type(other.get<value_type>());
+			tag_ = Index;
+		} else {
+			copy_construct_<Index + 1>(other);
+		}
+	}
+
+	template<size_t Index> requires (Index == sizeof...(T))
+	void copy_construct_(const variant &) {
+		FRG_ASSERT(!"Copy-construction from variant with illegal tag");
+	}
+
+	// construct the internal object by moving from another variant
+	template<size_t Index> requires (Index < sizeof...(T))
+	void move_construct_(variant &&other) {
+		using value_type = _variant::get<Index, T...>;
+		if(other.tag_ == Index) {
+			FRG_ASSERT(!*this);
+			new (access_()) value_type(std::move(other.get<value_type>()));
+			tag_ = Index;
+		} else {
+			move_construct_<Index + 1>(std::move(other));
+		}
+	}
+
+	template<size_t Index> requires (Index == sizeof...(T))
+	void move_construct_(variant &&) {
+		FRG_ASSERT(!"Move-construction from variant with illegal tag");
+	}
+
+	// destruct the internal object
+	template<size_t Index> requires (Index < sizeof...(T))
+	void destruct_() {
+		using value_type = _variant::get<Index, T...>;
+		if(tag_ == Index) {
+			get<value_type>().~value_type();
+			tag_ = invalid_tag;
+		} else {
+			destruct_<Index + 1>();
+		}
+	}
+
+	template<size_t Index> requires (Index == sizeof...(T))
+	void destruct_() {
+		FRG_ASSERT(!"Destruction of variant with illegal tag");
+	}
+
+	// assign the internal object
+	template<size_t Index> requires (Index < sizeof...(T))
+	void assign_(variant other) {
+		using value_type = _variant::get<Index, T...>;
+		if(tag_ == Index) {
+			get<value_type>() = std::move(other.get<value_type>());
+		} else {
+			assign_<Index + 1>(std::move(other));
+		}
+	}
+
+	template<size_t Index> requires (Index == sizeof...(T))
+	void assign_(variant) {
+		FRG_ASSERT(!"Assignment from variant with illegal tag");
+	}
+
+	// apply a functor to the internal object
+	template<typename F, size_t Index> requires (Index < sizeof...(T))
+	std::common_type_t<std::invoke_result_t<F, T&>...>
+	apply_(F functor) {
+		using value_type = _variant::get<Index, T...>;
+		if(tag_ == Index) {
+			return functor(get<value_type>());
+		} else {
+			return apply_<F, Index + 1>(std::move(functor));
+		}
+	}
+
+	template<typename F, size_t Index> requires (Index == sizeof...(T))
+	std::common_type_t<std::invoke_result_t<F, T&>...>
+	apply_(F) {
+		FRG_ASSERT(!"_apply() on variant with illegal tag");
+		__builtin_unreachable();
+	}
+
+	size_t tag_;
+	frg::aligned_union<T...> storage_;
+};
+
+} // namespace frg
diff --git a/mlibc/subprojects/frigg/include/frg/vector.hpp b/mlibc/subprojects/frigg/include/frg/vector.hpp
new file mode 100644
index 0000000..48032e5
--- /dev/null
+++ b/mlibc/subprojects/frigg/include/frg/vector.hpp
@@ -0,0 +1,214 @@
+#ifndef FRG_VECTOR_HPP
+#define FRG_VECTOR_HPP
+
+#include <utility>
+#include <stddef.h>
+
+#include <frg/macros.hpp>
+
+namespace frg FRG_VISIBILITY {
+
+template<typename T, typename Allocator>
+class vector {
+public:
+	using value_type = T;
+	using reference = value_type&;
+
+	friend void swap(vector &a, vector &b) {
+		using std::swap;
+		swap(a._allocator, b._allocator);
+		swap(a._elements, b._elements);
+		swap(a._size, b._size);
+		swap(a._capacity, b._capacity);
+	}
+
+	vector(Allocator allocator = Allocator());
+
+	vector(const vector &other)
+	: vector(other._allocator) {
+		auto other_size = other.size();
+		_ensure_capacity(other_size);
+		for (size_t i = 0; i < other_size; i++)
+			new (&_elements[i]) T(other[i]);
+		_size = other_size;
+	}
+
+	vector(vector &&other)
+	: vector(other._allocator) {
+		swap(*this, other);
+	}
+
+	~vector();
+
+	vector &operator= (vector other) {
+		swap(*this, other);
+		return *this;
+	}
+
+	T &push(const T &element);
+
+	T &push(T &&element);
+
+	T &push_back(const T &element) {
+		return push(element);
+	}
+
+	T &push_back(T &&element) {
+		return push(std::move(element));
+	}
+
+	template<typename... Args>
+	T &emplace_back(Args &&... args);
+
+	T pop();
+
+	template<typename... Args>
+	void resize(size_t new_size, Args &&... args);
+
+	void clear() {
+		for(size_t i = 0; i < _size; i++)
+			_elements[i].~T();
+		_size = 0;
+	}
+
+	T *data() {
+		return _elements;
+	}
+
+	const T *data() const {
+		return _elements;
+	}
+
+	size_t size() const {
+		return _size;
+	}
+
+	bool empty() const {
+		return size() == 0;
+	}
+
+	T *begin() {
+		return _elements;
+	}
+
+	const T *begin() const {
+		return _elements;
+	}
+
+	T *end() {
+		return _elements + _size;
+	}
+
+	const T *end() const {
+		return _elements + _size;
+	}
+
+	T &front() {
+		return _elements[0];
+	}
+	const T &front() const {
+		return _elements[0];
+	}
+
+	T &back() {
+		return _elements[_size - 1];
+	}
+	const T &back() const {
+		return _elements[_size - 1];
+	}
+
+	const T &operator[] (size_t index) const {
+		return _elements[index];
+	}
+	T &operator[] (size_t index) {
+		return _elements[index];
+	}
+
+private:
+	void _ensure_capacity(size_t capacity);
+
+	Allocator _allocator;
+	T *_elements;
+	size_t _size;
+	size_t _capacity;
+};
+
+template<typename T, typename Allocator>
+vector<T, Allocator>::vector(Allocator allocator)
+: _allocator{std::move(allocator)}, _elements{nullptr}, _size{0}, _capacity{0} { }
+
+template<typename T, typename Allocator>
+vector<T, Allocator>::~vector() {
+	for(size_t i = 0; i < _size; i++)
+		_elements[i].~T();
+	_allocator.free(_elements);
+}
+
+template<typename T, typename Allocator>
+T &vector<T, Allocator>::push(const T &element) {
+	_ensure_capacity(_size + 1);
+	T *pointer = new (&_elements[_size]) T(element);
+	_size++;
+	return *pointer;
+}
+
+template<typename T, typename Allocator>
+T &vector<T, Allocator>::push(T &&element) {
+	_ensure_capacity(_size + 1);
+	T *pointer = new (&_elements[_size]) T(std::move(element));
+	_size++;
+	return *pointer;
+}
+
+template<typename T, typename Allocator>
+template<typename... Args>
+T &vector<T, Allocator>::emplace_back(Args &&... args) {
+	_ensure_capacity(_size + 1);
+	T *pointer = new(&_elements[_size]) T(std::forward<Args>(args)...);
+	_size++;
+	return *pointer;
+}
+
+template<typename T, typename Allocator>
+template<typename... Args>
+void vector<T, Allocator>::resize(size_t new_size, Args &&... args) {
+	_ensure_capacity(new_size);
+	if(new_size < _size) {
+		for(size_t i = new_size; i < _size; i++)
+			_elements[i].~T();
+	}else{
+		for(size_t i = _size; i < new_size; i++)
+			new (&_elements[i]) T(std::forward<Args>(args)...);
+	}
+	_size = new_size;
+}
+
+template<typename T, typename Allocator>
+void vector<T, Allocator>::_ensure_capacity(size_t capacity) {
+	if(capacity <= _capacity)
+		return;
+
+	size_t new_capacity = capacity * 2;
+	T *new_array = (T *)_allocator.allocate(sizeof(T) * new_capacity);
+	for(size_t i = 0; i < _capacity; i++)
+		new (&new_array[i]) T(std::move(_elements[i]));
+
+	for(size_t i = 0; i < _size; i++)
+		_elements[i].~T();
+	_allocator.free(_elements);
+
+	_elements = new_array;
+	_capacity = new_capacity;
+}
+
+template<typename T, typename Allocator>
+T vector<T, Allocator>::pop() {
+	_size--;
+	T element = std::move(_elements[_size]);
+	_elements[_size].~T();
+	return element;
+}
+
+} // namespace frg
+
+#endif // FRG_VECTOR_HPP
diff --git a/mlibc/subprojects/frigg/meson.build b/mlibc/subprojects/frigg/meson.build
new file mode 100644
index 0000000..379f029
--- /dev/null
+++ b/mlibc/subprojects/frigg/meson.build
@@ -0,0 +1,47 @@
+project('frigg', 'cpp')
+
+incl = include_directories('include')
+
+if not get_option('frigg_no_install')
+	install_headers(
+		'include/frg/allocation.hpp',
+		'include/frg/array.hpp',
+		'include/frg/container_of.hpp',
+		'include/frg/eternal.hpp',
+		'include/frg/expected.hpp',
+		'include/frg/formatting.hpp',
+		'include/frg/functional.hpp',
+		'include/frg/hash.hpp',
+		'include/frg/hash_map.hpp',
+		'include/frg/intrusive.hpp',
+		'include/frg/list.hpp',
+		'include/frg/logging.hpp',
+		'include/frg/macros.hpp',
+		'include/frg/manual_box.hpp',
+		'include/frg/mutex.hpp',
+		'include/frg/optional.hpp',
+		'include/frg/pairing_heap.hpp',
+		'include/frg/qs.hpp',
+		'include/frg/random.hpp',
+		'include/frg/rbtree.hpp',
+		'include/frg/std_compat.hpp',
+		'include/frg/rcu_radixtree.hpp',
+		'include/frg/slab.hpp',
+		'include/frg/span.hpp',
+		'include/frg/string.hpp',
+		'include/frg/tuple.hpp',
+		'include/frg/utility.hpp',
+		'include/frg/vector.hpp',
+		'include/frg/unique.hpp',
+		'include/frg/detection.hpp',
+		subdir: 'frg')
+endif
+
+frigg_dep = declare_dependency(include_directories: incl)
+
+analyzer = executable(
+		'slab_trace_analyzer',
+		'slab_trace_analyzer.cpp',
+		cpp_args: ['-std=c++17', '-O3'],
+		build_by_default: false,
+		native: true)
diff --git a/mlibc/subprojects/frigg/meson_options.txt b/mlibc/subprojects/frigg/meson_options.txt
new file mode 100644
index 0000000..0961215
--- /dev/null
+++ b/mlibc/subprojects/frigg/meson_options.txt
@@ -0,0 +1 @@
+option('frigg_no_install', type : 'boolean', value : false)
diff --git a/mlibc/subprojects/frigg/slab_trace_analyzer.cpp b/mlibc/subprojects/frigg/slab_trace_analyzer.cpp
new file mode 100644
index 0000000..a057b92
--- /dev/null
+++ b/mlibc/subprojects/frigg/slab_trace_analyzer.cpp
@@ -0,0 +1,259 @@
+#include <iostream>
+#include <fstream>
+#include <vector>
+#include <unordered_map>
+#include <numeric>
+#include <algorithm>
+
+#include <string.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdio.h>
+
+struct mapped_file {
+	mapped_file(const char *path)
+	: data{nullptr}, size{0} {
+		int _fd = open(path, O_RDONLY);
+		if (_fd < 0) {
+			perror("failed to open file");
+			return;
+		}
+
+		struct stat st;
+		if (fstat(_fd, &st) < 0) {
+			perror("failed to stat file");
+			return;
+		}
+
+		size = st.st_size;
+
+		data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE, _fd, 0);
+		if (data == MAP_FAILED) {
+			data = nullptr;
+			perror("failed to mmap file");
+			return;
+		}
+
+		close(_fd);
+	}
+
+	~mapped_file() {
+		munmap(data, size);
+	}
+
+	void *data;
+	size_t size;
+};
+
+enum class type {
+	allocation,
+	deallocation
+};
+
+struct alloc_log {
+	type t;
+	uintptr_t ptr;
+	size_t size;
+	std::vector<uintptr_t> stack;
+};
+
+namespace std {
+
+template <>
+struct hash<std::vector<uintptr_t>> {
+	size_t operator()(const std::vector<uintptr_t> &vec) const {
+		size_t v = vec.size();
+
+		for(auto &i : vec) {
+			v ^= i + uintptr_t(0x9e3779b9) + (v << 6) + (v >> 2);
+		}
+
+		return v;
+	}
+};
+
+} // namespace std
+
+int main(int argc, char **argv) {
+	if (argc != 3) {
+		fprintf(stderr, "usage: <input file> <executable>\n");
+		return 1;
+	}
+
+	mapped_file in{argv[1]};
+	if (!in.data)
+		return 1;
+
+	uint8_t *data = static_cast<uint8_t *>(in.data);
+	size_t i = 0;
+
+	auto decode_varint = [](uint8_t *buffer, uintptr_t &target) -> size_t {
+		target = 0;
+		for (int i = 0; i < 8; i++)
+			target |= (uintptr_t(buffer[i]) << (i * 8));
+
+		return 8;
+	};
+
+	auto print_stack = [](const std::vector<uintptr_t> &stack) {
+		for (auto p : stack)
+			printf("\t%016lx\n", p);
+	};
+
+	std::vector<alloc_log> logs{};
+	std::unordered_map<uintptr_t, alloc_log *> unmatched_logs{};
+	std::unordered_map<std::vector<uintptr_t>, std::vector<size_t>> grouped_logs{};
+	std::vector<std::pair<std::vector<uintptr_t>, std::vector<size_t>>> leaks{};
+
+	while (i < in.size) {
+		char mode = data[i++];
+		uintptr_t pointer = 0;
+		uintptr_t size = 0;
+		std::vector<uintptr_t> stack;
+		stack.clear();
+
+		i += decode_varint(data + i, pointer);
+		if (mode == 'a')
+			i += decode_varint(data + i, size);
+
+		uintptr_t tmp = 0;
+		while (i < in.size) {
+			i += decode_varint(data + i, tmp);
+			if (tmp == 0xA5A5A5A5A5A5A5A5)
+				break;
+
+			stack.push_back(tmp);
+		}
+
+		logs.push_back({mode == 'a' ? type::allocation : type::deallocation, pointer, size, stack});
+	}
+
+	for (auto &l : logs) {
+		if (l.t == type::allocation) {
+			if (unmatched_logs.count(l.ptr)) {
+				printf("same address allocated again without matching free for previous call?\n");
+				printf("address %016lx got allocated again despite not being freed!\n", l.ptr);
+				printf("first allocation from:\n");
+				print_stack(unmatched_logs[l.ptr]->stack);
+				printf("allocation again from:\n");
+				print_stack(l.stack);
+			} else {
+				unmatched_logs[l.ptr] = &l;
+			}
+		} else {
+			if (unmatched_logs.count(l.ptr)) {
+				unmatched_logs.erase(l.ptr);
+			} else if (l.ptr) {
+				printf("deallocation of an address that wasn't allocated?\n");
+				printf("address %016lx isn't allocated anywhere at this point!\n", l.ptr);
+				printf("deallocated from:\n");
+				print_stack(l.stack);
+			}
+		}
+	}
+
+	for (auto &[ptr, l] : unmatched_logs) {
+		if (grouped_logs.count(l->stack)) {
+			grouped_logs[l->stack].push_back(l->size);
+		} else {
+			grouped_logs[l->stack] = {l->size};
+		}
+	}
+
+	for (auto &[stack, l] : grouped_logs) {
+		leaks.push_back(std::make_pair(stack, l));
+	}
+
+	std::sort(leaks.begin(), leaks.end(),
+		[](auto &a, auto &b){
+			return std::accumulate(a.second.begin(), a.second.end(), 0)
+				< std::accumulate(b.second.begin(), b.second.end(), 0);
+		}
+	);
+
+	int stdin_pipe[2];
+	int stdout_pipe[2];
+	pipe(stdin_pipe);
+	pipe(stdout_pipe);
+
+	// setup addr2line things
+	pid_t addr2line_pid = fork();
+	if (addr2line_pid < 0) {
+		perror("fork failed");
+		return 1;
+	}
+
+	if (!addr2line_pid) {
+		dup2(stdin_pipe[0], STDIN_FILENO);
+		dup2(stdout_pipe[1], STDOUT_FILENO);
+		execl("/usr/bin/addr2line", "addr2line", "-Cpfse", argv[2], nullptr);
+	}
+
+	// write to stdin_pipe[1], read from stdout_pipe[0]
+	FILE *stdin_f = fdopen(stdin_pipe[1], "w"), *stdout_f = fdopen(stdout_pipe[0], "r");
+
+	if (!stdin_f) {
+		perror("failed to open stdin pipe");
+		return 1;
+	}
+
+	if (!stdout_f) {
+		perror("failed to open stdout pipe");
+		return 1;
+	}
+
+	size_t total_all = 0;
+
+	char *linebuf = nullptr;
+	size_t linecap = 0;
+
+	for (auto &[stack, l] : leaks) {
+		size_t avg = std::accumulate(l.begin(), l.end(), 0) / l.size();
+		size_t total = std::accumulate(l.begin(), l.end(), 0);
+		total_all += total;
+		printf("%lu potential leak(s) found of average size %lu, total size %lu, and all sizes:\n  ", l.size(), avg, total);
+
+		std::sort(l.begin(), l.end());
+
+		size_t i = 0;
+
+		while (i < l.size()) {
+			size_t n = std::count(l.begin(), l.end(), l[i]);
+
+			if (n == 1)
+				printf("%lu", l[i]);
+			else
+				printf("%lux %lu", n, l[i]);
+
+			i += n;
+			printf("%s", i < l.size() ? ", " : "");
+		}
+
+		printf("\n  found in:\n");
+		for (auto p : stack) {
+			fprintf(stdin_f, "0x%016lx\n", p);
+			fflush(stdin_f);
+			getline(&linebuf, &linecap, stdout_f);
+
+			printf("\t%016lx -> %s", p, linebuf);
+		}
+		printf("--------------------------------------\n\n");
+	}
+
+	free(linebuf);
+	fclose(stdin_f);
+	fclose(stdout_f);
+	close(stdin_pipe[1]);
+	close(stdout_pipe[0]);
+
+	printf("total potential leaks: %lu, which is %lu bytes\n", unmatched_logs.size(), total_all);
+
+	kill(addr2line_pid, SIGTERM);
+	int wstatus;
+	waitpid(addr2line_pid, &wstatus, 0);
+}
diff --git a/mlibc/sysdeps/echidnaos/crt-i386/crt0.S b/mlibc/sysdeps/echidnaos/crt-i386/crt0.S
new file mode 100644
index 0000000..3aad212
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/crt-i386/crt0.S
@@ -0,0 +1,11 @@
+.section .echidnaos_entry
+.global _start
+_start:
+    push $main
+    call __mlibc_entry
+
+.section .text
+.global ___tls_get_addr
+___tls_get_addr:
+    mov $0x12348765, %eax
+    jmp ___tls_get_addr
diff --git a/mlibc/sysdeps/echidnaos/generic/entry.cpp b/mlibc/sysdeps/echidnaos/generic/entry.cpp
new file mode 100644
index 0000000..282953f
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/generic/entry.cpp
@@ -0,0 +1,20 @@
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <bits/ensure.h>
+#include <mlibc/elf/startup.h>
+
+#include <mlibc/all-sysdeps.hpp>
+
+extern char **environ;
+
+extern "C" void __mlibc_entry(int (*main_fn)(int argc, char *argv[], char *env[])) {
+    int argc = *((int *)0x1000);
+    char **argv = (char **)0x1010;
+
+    __mlibc_run_constructors();
+
+	auto result = main_fn(argc, argv, environ);
+	exit(result);
+}
+
diff --git a/mlibc/sysdeps/echidnaos/generic/generic.cpp b/mlibc/sysdeps/echidnaos/generic/generic.cpp
new file mode 100644
index 0000000..c0bcab4
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/generic/generic.cpp
@@ -0,0 +1,147 @@
+
+#include <bits/ensure.h>
+#include <mlibc/debug.hpp>
+#include <mlibc/all-sysdeps.hpp>
+#include <errno.h>
+#include <dirent.h>
+#include <fcntl.h>
+
+#define STUB_ONLY { __ensure(!"STUB_ONLY function was called"); __builtin_unreachable(); }
+
+namespace mlibc {
+    // The basics
+    void sys_libc_log(const char *message) {
+        int discard;
+        asm volatile (
+            "int $0x80"
+            : "=a"(discard)
+            : "a"(4), "c"(message)
+            : "edx", "memory"
+        );
+    }
+    void sys_libc_panic() {
+        sys_libc_log("\nmlibc: panic.\n");
+        for (;;);
+    }
+
+    int sys_getcwd(char *buffer, size_t size) {
+        mlibc::infoLogger() << "mlibc: in sys_getcwd"<< frg::endlog;
+        int discard;
+        asm volatile (
+            "int $0x80"
+            : "=a"(discard)
+            : "a"(0x1a), "c"(buffer)
+            : "edx", "memory"
+        );
+    }
+
+    // Memory Related Functions
+    int sys_anon_free(void *pointer, size_t size) {
+        mlibc::infoLogger() << "mlibc: in sys_anon_free"<< frg::endlog;
+        return -1;
+    }
+
+    int sys_anon_allocate(size_t size, void **pointer) {
+        mlibc::infoLogger() << "mlibc: in sys_anon_allocate"<< frg::endlog;
+        int discard;
+        size_t heap_base;
+        size_t heap_size;
+        asm volatile (
+            "mov $0x10, %%eax;"
+            "int $0x80;"
+            "mov %%eax, %%ebx;"
+            "mov $0x11, %%eax;"
+            "int $0x80;"
+            : "=b" (heap_base), "=a" (heap_size)
+            :
+            : "edx", "memory"
+        );
+        size_t ptr = heap_base + heap_size;
+        asm volatile (
+            "int $0x80"
+            : "=a"(discard)
+            : "a"(0x12), "c"(heap_size + size)
+            : "edx", "memory"
+        );
+        mlibc::infoLogger() << "mlibc: " << __func__ << " returning " << (void*)ptr
+            << frg::endlog;
+    	*pointer = (void*)ptr;
+        return 0;
+    }
+
+    // Misc functions
+    int sys_clock_get(int clock, time_t *secs, long *nanos) STUB_ONLY
+
+    // TODO: Actually implement this
+    int sys_futex_wait(int *pointer, int expected) STUB_ONLY
+    int sys_futex_wake(int *pointer) STUB_ONLY
+
+    // Task functions
+    void sys_exit(int status) STUB_ONLY
+    int sys_tcb_set(void *pointer) STUB_ONLY
+
+    // File functions
+    int sys_open(const char *path, int flags, int *fd) STUB_ONLY
+    int sys_close(int fd) STUB_ONLY
+
+    int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
+        mlibc::infoLogger() << "mlibc: in sys_seek"<< frg::endlog;
+        int discard;
+        off_t ret;
+
+        switch (whence) {
+            case SEEK_SET:
+                whence = 0;
+                break;
+            case SEEK_END:
+                whence = 1;
+                break;
+            case SEEK_CUR:
+                whence = 2;
+                break;
+        }
+
+        asm volatile ("int $0x80"
+                : "=a"(ret), "=d"(discard)
+                : "a"(0x2e), "c"(fd), "d"(offset), "D"(whence)
+                : "memory"
+        );
+
+        *new_offset = ret;
+
+        return 0;
+    }
+
+    int sys_read(int fd, void *buf, size_t count, ssize_t *bytes_read) {
+        mlibc::infoLogger() << "mlibc: in sys_read"<< frg::endlog;
+        int discard0, discard1;
+        asm volatile ("int $0x80"
+                : "=a"(discard0), "=d"(discard1)
+                : "a"(0x2c), "c"(fd), "d"(buf), "D"(count)
+                : "memory"
+        );
+
+        *bytes_read = count;
+        return 0;
+    }
+
+    int sys_write(int fd, const void *buf, size_t count, ssize_t *bytes_written) {
+        mlibc::infoLogger() << "mlibc: in sys_write"<< frg::endlog;
+        int discard0, discard1;
+        asm volatile ("int $0x80"
+                : "=a"(discard0), "=d"(discard1)
+                : "a"(0x2d), "c"(fd), "d"(buf), "D"(count)
+                : "memory"
+        );
+
+        *bytes_written = count;
+        return 0;
+    }
+
+    int sys_isatty(int fd) {
+        mlibc::infoLogger() << "mlibc: in sys_isatty"<< frg::endlog;
+        return 0;
+    }
+
+} // namespace mlibc
+
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/abi.h b/mlibc/sysdeps/echidnaos/include/abi-bits/abi.h
new file mode 120000
index 0000000..c945860
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/abi.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/abi.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/auxv.h b/mlibc/sysdeps/echidnaos/include/abi-bits/auxv.h
new file mode 120000
index 0000000..b7bb109
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/auxv.h
@@ -0,0 +1 @@
+../../../../abis/qword/auxv.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/blkcnt_t.h b/mlibc/sysdeps/echidnaos/include/abi-bits/blkcnt_t.h
new file mode 120000
index 0000000..e9d9f1b
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/blkcnt_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/blkcnt_t.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/blksize_t.h b/mlibc/sysdeps/echidnaos/include/abi-bits/blksize_t.h
new file mode 120000
index 0000000..c6dfb6e
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/blksize_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/blksize_t.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/dev_t.h b/mlibc/sysdeps/echidnaos/include/abi-bits/dev_t.h
new file mode 120000
index 0000000..0c1143b
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/dev_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/dev_t.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/errno.h b/mlibc/sysdeps/echidnaos/include/abi-bits/errno.h
new file mode 120000
index 0000000..589859f
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/errno.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/errno.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/fcntl.h b/mlibc/sysdeps/echidnaos/include/abi-bits/fcntl.h
new file mode 120000
index 0000000..ea5323a
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/fcntl.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/fcntl.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/gid_t.h b/mlibc/sysdeps/echidnaos/include/abi-bits/gid_t.h
new file mode 120000
index 0000000..6a77218
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/gid_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/gid_t.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/in.h b/mlibc/sysdeps/echidnaos/include/abi-bits/in.h
new file mode 120000
index 0000000..b58c683
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/in.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/in.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/ino_t.h b/mlibc/sysdeps/echidnaos/include/abi-bits/ino_t.h
new file mode 120000
index 0000000..10d644e
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/ino_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/ino_t.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/mode_t.h b/mlibc/sysdeps/echidnaos/include/abi-bits/mode_t.h
new file mode 120000
index 0000000..29d7733
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/mode_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/mode_t.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/nlink_t.h b/mlibc/sysdeps/echidnaos/include/abi-bits/nlink_t.h
new file mode 120000
index 0000000..7618c27
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/nlink_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/nlink_t.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/pid_t.h b/mlibc/sysdeps/echidnaos/include/abi-bits/pid_t.h
new file mode 120000
index 0000000..3fd26a7
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/pid_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/pid_t.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/resource.h b/mlibc/sysdeps/echidnaos/include/abi-bits/resource.h
new file mode 120000
index 0000000..3e59c75
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/resource.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/resource.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/seek-whence.h b/mlibc/sysdeps/echidnaos/include/abi-bits/seek-whence.h
new file mode 120000
index 0000000..3bd41ef
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/seek-whence.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/seek-whence.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/signal.h b/mlibc/sysdeps/echidnaos/include/abi-bits/signal.h
new file mode 120000
index 0000000..b20e511
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/signal.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/signal.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/socket.h b/mlibc/sysdeps/echidnaos/include/abi-bits/socket.h
new file mode 120000
index 0000000..0e1d6be
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/socket.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/socket.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/stat.h b/mlibc/sysdeps/echidnaos/include/abi-bits/stat.h
new file mode 120000
index 0000000..82642c3
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/stat.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/stat.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/termios.h b/mlibc/sysdeps/echidnaos/include/abi-bits/termios.h
new file mode 120000
index 0000000..cfcfe76
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/termios.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/termios.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/time.h b/mlibc/sysdeps/echidnaos/include/abi-bits/time.h
new file mode 120000
index 0000000..97f3d52
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/time.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/time.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/uid_t.h b/mlibc/sysdeps/echidnaos/include/abi-bits/uid_t.h
new file mode 120000
index 0000000..1113eba
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/uid_t.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/uid_t.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/abi-bits/vm-flags.h b/mlibc/sysdeps/echidnaos/include/abi-bits/vm-flags.h
new file mode 120000
index 0000000..f1a985e
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/abi-bits/vm-flags.h
@@ -0,0 +1 @@
+../../../../abis/mlibc/vm-flags.h
\ No newline at end of file
diff --git a/mlibc/sysdeps/echidnaos/include/sys_api.h b/mlibc/sysdeps/echidnaos/include/sys_api.h
new file mode 100644
index 0000000..af0a346
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/include/sys_api.h
@@ -0,0 +1,425 @@
+/*
+ *  echidnaOS kernel API
+ */
+
+#ifndef __SYS_API_H__
+#define __SYS_API_H__
+
+#include <stdint.h>
+
+typedef struct {
+    char filename[2048];
+    int filetype;
+    uint64_t size;
+} vfs_metadata_t;
+
+typedef struct {
+    char* path;
+    char* ti_stdin;
+    char* ti_stdout;
+    char* ti_stderr;
+    char* pwd;
+    char* name;
+    char* server_name;
+    int argc;
+    char** argv;
+} task_info_t;
+
+#define VFS_FILE_TYPE 0
+#define VFS_DIRECTORY_TYPE 1
+#define VFS_DEVICE_TYPE 2
+#define VFS_SUCCESS 0
+#define VFS_FAILURE -2
+
+#define ECH_O_RDONLY        0b0001
+#define ECH_O_WRONLY        0b0010
+#define ECH_O_RDWR          0b0100
+
+#define ECH_O_APPEND        0b001000
+#define ECH_O_CREAT         0b010000
+#define ECH_O_TRUNC         0b100000
+
+#define ECH_SEEK_SET 0
+#define ECH_SEEK_END 1
+#define ECH_SEEK_CUR 2
+
+#define OS_open(path, flags, mode) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x2a, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (path),  \
+                       "d" (flags), \
+                       "D" (mode) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_close(handle) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x2b, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (handle) \
+                     : "edx" );         \
+    return_val;                                \
+})
+
+#define OS_read(handle, buf, len) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x2c, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (handle),  \
+                       "d" (buf), \
+                       "D" (len) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_write(handle, buf, len) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x2d, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (handle),  \
+                       "d" (buf), \
+                       "D" (len) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_lseek(a, b, c) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x2e, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (a),  \
+                       "d" (b), \
+                       "D" (c) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_signal(sig, handler) ({ \
+    int ret; \
+    asm volatile (  "movl $0x16, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret)                 \
+                     : "c" (sig),        \
+                       "d" (handler)    \
+                     :  );         \
+    ret; \
+})
+
+#define OS_getpid() ({              \
+    uint32_t val;                         \
+    asm volatile (  "movl $0x15, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (val)      \
+                     : \
+                     : "edx" );         \
+    val;                               \
+})
+
+#define OS_get_heap_base() ({              \
+    uint32_t val;                         \
+    asm volatile (  "movl $0x10, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (val)      \
+                     : \
+                     : "edx" );         \
+    val;                               \
+})
+
+#define OS_get_heap_size() ({              \
+    uint32_t val;                         \
+    asm volatile (  "movl $0x11, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (val)      \
+                     : \
+                     : "edx" );         \
+    val;                               \
+})
+
+#define OS_resize_heap(val) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x12, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)      \
+                     : "c" (val)  \
+                     : "edx" );         \
+    return_val;                                \
+})
+
+#define OS_pwd(value) ({                \
+    asm volatile (  "movl $0x1a, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     :                  \
+                     : "c" (value)      \
+                     : "eax", "edx" );  \
+})
+
+#define OS_what_stdin(value) ({                \
+    asm volatile (  "movl $0x1b, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     :                  \
+                     : "c" (value)      \
+                     : "eax", "edx" );  \
+})
+
+#define OS_what_stdout(value) ({                \
+    asm volatile (  "movl $0x1c, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     :                  \
+                     : "c" (value)      \
+                     : "eax", "edx" );  \
+})
+
+#define OS_what_stderr(value) ({                \
+    asm volatile (  "movl $0x1d, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     :                  \
+                     : "c" (value)      \
+                     : "eax", "edx" );  \
+})
+
+#define OS_ipc_send_packet(pid, payload, len) ({ \
+    asm volatile (  "movl $0x08, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     :                  \
+                     : "c" (pid),        \
+                       "d" (payload),    \
+                       "D" (len)      \
+                     : "eax" );         \
+})
+
+#define OS_ipc_read_packet(payload) ({  \
+    uint32_t pid;                            \
+    asm volatile (  "movl $0x09, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (pid)         \
+                     : "c" (payload)    \
+                     : "edx" );         \
+    pid;                                \
+})
+
+#define OS_ipc_resolve_name(server_name) ({  \
+    uint32_t pid;                            \
+    asm volatile (  "movl $0x0a, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (pid)         \
+                     : "c" (server_name)  \
+                     : "edx" );         \
+    pid;                                \
+})
+
+#define OS_ipc_payload_sender() ({      \
+    uint32_t pid;                              \
+    asm volatile (  "movl $0x0b, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (pid)         \
+                     :                  \
+                     : "edx" );         \
+    pid;                                  \
+})
+
+#define OS_ipc_payload_length() ({      \
+    uint32_t pid;                              \
+    asm volatile (  "movl $0x0c, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (pid)         \
+                     :                  \
+                     : "edx" );         \
+    pid;                                  \
+})
+
+#define OS_ipc_await() ({                \
+    asm volatile (  "movl $0x0d, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     :                  \
+                     :                    \
+                     :  );  \
+})
+
+#define OS_vfs_list(path, metadata, entry) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x32, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (path),  \
+                       "d" (metadata), \
+                       "D" (entry) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_vfs_get_metadata(path, metadata, type) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x33, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (path),  \
+                       "d" (metadata), \
+                       "D" (type) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_vfs_read(path, loc) ({  \
+    int return_val;                            \
+    uint32_t loc_low = loc & 0x00000000ffffffff; \
+    uint32_t loc_high = loc / 0x100000000; \
+    asm volatile (  "movl $0x30, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (path),  \
+                       "d" (loc_low), \
+                       "D" (loc_high) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_vfs_write(path, loc, val) ({  \
+    int return_val;                            \
+    uint32_t loc_low = loc & 0x00000000ffffffff; \
+    uint32_t loc_high = loc / 0x100000000; \
+    asm volatile (  "movl $0x31, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)         \
+                     : "c" (path),  \
+                       "d" (loc_low), \
+                       "D" (loc_high), \
+                       "S" (val) \
+                     :  );         \
+    return_val;                                \
+})
+
+#define OS_vfs_mkdir(path, perms) ({ \
+    int ret; \
+    asm volatile (  "movl $0x35, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret)                 \
+                     : "c" (path),        \
+                       "d" (perms)    \
+                     :  );         \
+    ret; \
+})
+
+#define OS_vfs_create(path, perms) ({ \
+    int ret; \
+    asm volatile (  "movl $0x36, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret)                 \
+                     : "c" (path),        \
+                       "d" (perms)    \
+                     :  );         \
+    ret; \
+})
+
+#define OS_vfs_cd(path) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x2f, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)      \
+                     : "c" (path)  \
+                     : "edx" );         \
+    return_val;                                \
+})
+
+#define OS_vfs_remove(path) ({  \
+    int return_val;                            \
+    asm volatile (  "movl $0x34, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (return_val)      \
+                     : "c" (path)  \
+                     : "edx" );         \
+    return_val;                                \
+})
+
+#define OS_vdev_in_ready(value) ({               \
+    int ret; \
+    asm volatile (  "movl $0x21, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret) \
+                     : "c" (value)      \
+                     : "edx" );  \
+    ret; \
+})
+
+#define OS_vdev_out_ready(value) ({               \
+    int ret; \
+    asm volatile (  "movl $0x22, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret) \
+                     : "c" (value)      \
+                     : "edx" );  \
+    ret; \
+})
+
+#define OS_vdev_register(in, fin, out, fout) ({ \
+    int ret; \
+    asm volatile (  "movl $0x20, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret)                 \
+                     : "c" (in),        \
+                       "d" (fin),    \
+                       "D" (out), \
+                       "S" (fout) \
+                     :  );         \
+    ret; \
+})
+
+#define OS_vdev_await() ({                \
+    int ret; \
+    asm volatile (  "movl $0x23, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret)                 \
+                     :                    \
+                     : "edx" );  \
+    ret; \
+})
+
+#define OS_general_execute(value) ({               \
+    int ret; \
+    asm volatile (  "movl $0x01, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret) \
+                     : "c" (value)      \
+                     : "edx" );  \
+    ret; \
+})
+
+#define OS_general_execute_block(value) ({               \
+    uint32_t ret_low; \
+    uint32_t ret_hi; \
+    uint64_t ret; \
+    asm volatile (  "movl $0x02, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret_low),                 \
+                       "=d" (ret_hi) \
+                     : "c" (value)      \
+                     :  );  \
+    ret = ((uint64_t)(ret_hi) << 32) + (uint64_t)ret_low; \
+    ret; \
+})
+
+#define OS_exit(value) ({               \
+    asm volatile (  "movl $0x00, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : \
+                     : "c" (value)      \
+                     : "eax", "edx" );  \
+})
+
+#define OS_fork() ({               \
+    int ret; \
+    asm volatile (  "movl $0x05, %%eax\n\t"    \
+                    "int $0x80\n\t"         \
+                     : "=a" (ret) \
+                     :     \
+                     : "edx" );  \
+    ret; \
+})
+
+#endif
diff --git a/mlibc/sysdeps/echidnaos/meson.build b/mlibc/sysdeps/echidnaos/meson.build
new file mode 100644
index 0000000..be98069
--- /dev/null
+++ b/mlibc/sysdeps/echidnaos/meson.build
@@ -0,0 +1,47 @@
+libc_sources += files(
+	'generic/entry.cpp',
+	'generic/generic.cpp',
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/abi.h',
+		'include/abi-bits/auxv.h',
+		'include/abi-bits/seek-whence.h',
+		'include/abi-bits/vm-flags.h',
+		'include/abi-bits/errno.h',
+		'include/abi-bits/fcntl.h',
+		'include/abi-bits/in.h',
+		'include/abi-bits/resource.h',
+		'include/abi-bits/stat.h',
+		'include/abi-bits/signal.h',
+		'include/abi-bits/socket.h',
+		'include/abi-bits/termios.h',
+		'include/abi-bits/time.h',
+		'include/abi-bits/blkcnt_t.h',
+		'include/abi-bits/blksize_t.h',
+		'include/abi-bits/dev_t.h',
+		'include/abi-bits/gid_t.h',
+		'include/abi-bits/ino_t.h',
+		'include/abi-bits/mode_t.h',
+		'include/abi-bits/nlink_t.h',
+		'include/abi-bits/pid_t.h',
+		'include/abi-bits/uid_t.h',
+		subdir: 'abi-bits'
+	)
+	install_headers(
+		'include/sys_api.h',
+	)
+endif
+
+if not headers_only
+	custom_target('crt0',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-i386/crt0.S',
+		output: 'crt0.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
+
